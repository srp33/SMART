{% extends "base.html" %}
{% set document_name = doc.filename if doc and doc.filename else None %}
{% block download_button %}
{% if user['role'] == 'student' %}
<button id="download-pdf-btn" class="button is-outlined is-small" onclick="downloadDocumentPDF(event)" style="color: #000000; border-color: #000000;">Download</button>
{% endif %}
{% endblock %}
{% block navigation_buttons %}
{% if page and page.document_id and all_pages is defined and all_pages and current_page_id is defined and page_urls is defined %}
<div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem;">
  <div class="dropdown" style="display: inline-block;">
    <div class="dropdown-trigger">
      <button class="button is-light is-small" aria-haspopup="true" aria-controls="pages-dropdown-menu" aria-expanded="false" style="text-decoration: none;" onclick="event.stopPropagation(); this.closest('.dropdown').classList.toggle('is-active');">
        <span>Pages</span>
        <span class="icon is-small">
          <i class="fas fa-angle-down" aria-hidden="true"></i>
        </span>
      </button>
    </div>
    <div class="dropdown-menu" id="pages-dropdown-menu" role="menu">
      <div class="dropdown-content">
        {% for p in all_pages %}
        {% if p.id == current_page_id %}
        <span class="dropdown-item is-active" style="cursor: default; background-color: #3273dc; color: #fff; font-weight: 600;">
          Page {{ p.page_index + 1 }}
        </span>
        {% else %}
        <a href="{{ page_urls[p.id] }}" class="dropdown-item">
          Page {{ p.page_index + 1 }}
        </a>
        {% endif %}
        {% endfor %}
      </div>
    </div>
  </div>
  {% if prev_page_id %}
  <a class="button is-light is-small" href="{{ url_for('page', page_id=prev_page_id) }}">â† Previous</a>
  {% endif %}
  {% if next_page_id %}
  <a class="button is-light is-small" href="{{ url_for('page', page_id=next_page_id) }}">Next â†’</a>
  {% endif %}
</div>
{% elif page and page.document_id %}
<div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem;">
  {% if prev_page_id %}
  <a class="button is-light is-small" href="{{ url_for('page', page_id=prev_page_id) }}">â† Previous</a>
  {% endif %}
  {% if next_page_id %}
  <a class="button is-light is-small" href="{{ url_for('page', page_id=next_page_id) }}">Next â†’</a>
  {% endif %}
</div>
{% endif %}
{% endblock %}
{% block content %}
<!-- Debug: User role is {{ user['role'] }} -->
<div class="box">
  <div class="level mb-4">
    <div class="level-right">
      <div class="level-item">
        <p class="has-text-grey">Page {{ page.page_index + 1 }}/{{ total_pages }}</p>
      </div>
    </div>
  </div>

  <div class="columns">

    <!-- LEFT: Canvas and tools -->
    <div class="column is-two-thirds">
      {% if user['role'] == 'student' %}
      <div class="toolbar mb-4">
        <div class="buttons">
          <div class="dropdown is-hoverable" id="color-picker-container">
            <div class="dropdown-trigger">
              <button class="button" id="color-picker-btn" aria-haspopup="true" aria-controls="color-menu" style="padding-left: 0.75rem; padding-right: 0.75rem; background-color: #FFFFFF; border: 1px solid #FF0000; color: #FF0000;" title="Color">
                <span class="icon">
                  <i class="fas fa-palette" id="color-picker-icon"></i>
                </span>
              </button>
            </div>
            <div class="dropdown-menu" id="color-menu" role="menu">
              <div class="dropdown-content" style="padding: 0.5rem;">
                <div class="color-picker-grid" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem; width: 200px;">
                  <button class="color-btn" data-color="#000000" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #000000;" title="Black"></button>
                  <button class="color-btn" data-color="#FFFFFF" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FFFFFF;" title="White"></button>
                  <button class="color-btn" data-color="#FF0000" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FF0000;" title="Red"></button>
                  <button class="color-btn" data-color="#00FF00" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #00FF00;" title="Green"></button>
                  <button class="color-btn" data-color="#0000FF" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #0000FF;" title="Blue"></button>
                  <button class="color-btn" data-color="#FFFF00" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FFFF00;" title="Yellow"></button>
                  <button class="color-btn" data-color="#FF00FF" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FF00FF;" title="Magenta"></button>
                  <button class="color-btn" data-color="#00FFFF" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #00FFFF;" title="Cyan"></button>
                  <button class="color-btn" data-color="#FFA500" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FFA500;" title="Orange"></button>
                  <button class="color-btn" data-color="#800080" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #800080;" title="Purple"></button>
                  <button class="color-btn" data-color="#FFC0CB" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FFC0CB;" title="Pink"></button>
                  <button class="color-btn" data-color="#A52A2A" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #A52A2A;" title="Brown"></button>
                  <button class="color-btn" data-color="#808080" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #808080;" title="Gray"></button>
                  <button class="color-btn" data-color="#008000" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #008000;" title="Dark Green"></button>
                  <button class="color-btn" data-color="#000080" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #000080;" title="Navy"></button>
                </div>
              </div>
            </div>
          </div>
          <input class="input" id="color-input" type="hidden" value="#FF0000">
          <button class="button is-dark is-outlined" id="tool-rect">
            <span class="icon is-small" style="margin-right: 0.25rem;">
              <i class="far fa-square"></i>
            </span>
            <span>Rectangle</span>
          </button>
          <button class="button is-dark is-outlined" id="tool-line">
            <span class="icon is-small" style="margin-right: 0.25rem;">
              <i class="fas fa-minus"></i>
            </span>
            <span>Line</span>
          </button>
          <button class="button is-dark is-outlined" id="tool-freehand">
            <span class="icon is-small" style="margin-right: 0.25rem;">
              <i class="fas fa-pencil"></i>
            </span>
            <span>Freehand</span>
          </button>
          <button class="button is-dark is-outlined" id="tool-text">
            <span class="icon is-small" style="margin-right: 0.25rem;">
              <i class="fas fa-font"></i>
            </span>
            <span>Text</span>
          </button>
          <button class="button is-dark is-outlined" id="tool-move">
            <span class="icon is-small" style="margin-right: 0.25rem;">
              <i class="fas fa-arrows-alt"></i>
            </span>
            <span>Move</span>
          </button>
          <button class="button is-dark is-outlined" id="tool-delete">
            <span class="icon is-small" style="margin-right: 0.25rem;">
              <i class="far fa-trash-alt"></i>
            </span>
            <span>Delete</span>
          </button>
          <button class="button is-dark is-outlined" id="download-png-btn" href="#" onclick="downloadAnnotatedPNG(event); return false;" style="display: none;">
            <span>Download PNG</span>
          </button>
        </div>
      </div>
      {% endif %}

      <div style="position:relative; display:inline-block;">
        <img id="page-img"
             src="{{ page.image_url }}"
             class="page-image">
        {% if user['role'] == 'student' %}
        <canvas id="annot-canvas" style="position:absolute; left:0; top:0; pointer-events: auto;"></canvas>
        {% endif %}
      </div>
    </div>

    <!-- RIGHT: Emoji panel -->
    <div class="column is-one-third">
      {% if user['role'] == 'student' %}
      <h2 class="title is-5">How are you feeling on this page?</h2>
      <p class="mb-3 has-text-grey">Select one emotion. Only one can be active.</p>

      <div id="emoji-panel" class="is-flex is-flex-wrap-wrap" style="gap:.75rem;">
        <button class="button is-light emoji-btn" data-emoji="ğŸ¤©" title="Excited">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ğŸ¤©</span>
            <span style="font-size:.8rem;">Excited</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="ğŸ™‚" title="Okay/Happy">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ğŸ™‚</span>
            <span style="font-size:.8rem;">Okay</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="ğŸ˜•" title="Confused">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ğŸ˜•</span>
            <span style="font-size:.8rem;">Confused</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="ğŸ˜¤" title="Frustrated">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ğŸ˜¤</span>
            <span style="font-size:.8rem;">Frustrated</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="ğŸ˜¢" title="Overwhelmed">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ğŸ˜¢</span>
            <span style="font-size:.8rem;">Overwhelmed</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="ğŸ˜´" title="Bored/Tired">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ğŸ˜´</span>
            <span style="font-size:.8rem;">Bored</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="ğŸ˜¡" title="Triggered">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ğŸ˜¡</span>
            <span style="font-size:.8rem;">Triggered</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="ğŸ˜²" title="Surprised">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ğŸ˜²</span>
            <span style="font-size:.8rem;">Surprised</span>
          </div>
        </button>
      </div>
      {% else %}
      <h2 class="title is-5">Student Emotions</h2>
      <p class="mb-3 has-text-grey">Emotion counts for this page:</p>

      <div class="box">
        <div class="content">
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ğŸ¤©</span>
              </div>
              <div class="level-item">
                <span><strong>Excited</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ğŸ¤©', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ğŸ™‚</span>
              </div>
              <div class="level-item">
                <span><strong>Okay</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ğŸ™‚', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ğŸ˜•</span>
              </div>
              <div class="level-item">
                <span><strong>Confused</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ğŸ˜•', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ğŸ˜¤</span>
              </div>
              <div class="level-item">
                <span><strong>Frustrated</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ğŸ˜¤', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ğŸ˜¢</span>
              </div>
              <div class="level-item">
                <span><strong>Overwhelmed</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ğŸ˜¢', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ğŸ˜´</span>
              </div>
              <div class="level-item">
                <span><strong>Bored</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ğŸ˜´', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ğŸ˜¡</span>
              </div>
              <div class="level-item">
                <span><strong>Triggered</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ğŸ˜¡', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ğŸ˜²</span>
              </div>
              <div class="level-item">
                <span><strong>Surprised</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ğŸ˜²', 0) }}</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      {% endif %}
    </div>

  </div>
</div>

<!-- Navigation buttons at bottom -->
<div class="box mt-4">
  <div class="level">
    <div class="level-left">
      <div class="level-item">
        {% if prev_page_id %}
        <a class="button is-dark is-outlined" href="{{ url_for('page', page_id=prev_page_id) }}">â† Previous</a>
        {% endif %}
      </div>
    </div>
    <div class="level-right">
      <div class="level-item">
        {% if next_page_id %}
        <a class="button is-dark is-outlined" href="{{ url_for('page', page_id=next_page_id) }}">Next â†’</a>
        {% endif %}
      </div>
    </div>
  </div>
</div>

{% if user['role'] == 'student' %}
<!-- Inline Text Input -->
<div id="inline-text-container" style="position: fixed; display: none; z-index: 1000; align-items: flex-end;">
  <textarea id="inline-text-input" style="border: 2px solid #007bff; border-radius: 4px; padding: 4px 8px; font-size: 16px; font-family: sans-serif; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.2); min-width: 200px; max-width: 400px; resize: vertical; line-height: 1.4;"></textarea>
  <button id="inline-text-save-btn" style="margin-left: 4px; padding: 4px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; height: fit-content; align-self: flex-end;">Save</button>
</div>
{% endif %}

<style>
  .emoji-btn.is-selected { box-shadow: 0 0 0 2px #485fc7 inset; }
  .modal-card {
    max-width: 500px;
  }
</style>

{% if user['role'] == 'student' %}
<script>
  const pageId = {{ page.id }};
  let existing = {{ annotations|tojson }};
  let currentEmoji = {{ (current_emoji or 'null')|tojson }};

  const img = document.getElementById('page-img');
  const canvas = document.getElementById('annot-canvas');
  const ctx = canvas.getContext('2d');

  const toolRectBtn = document.getElementById('tool-rect');
  const toolTextBtn = document.getElementById('tool-text');
  const toolLineBtn = document.getElementById('tool-line');
  const toolFreehandBtn = document.getElementById('tool-freehand');
  const toolMoveBtn = document.getElementById('tool-move');
  const deleteBtn   = document.getElementById('tool-delete');
  const colorInput = document.getElementById('color-input');
  const colorPickerBtn = document.getElementById('color-picker-btn');
  
  // Inline text input elements
  const inlineTextContainer = document.getElementById('inline-text-container');
  const inlineTextInput = document.getElementById('inline-text-input');
  const inlineTextSaveBtn = document.getElementById('inline-text-save-btn');

  let tool = 'rect';
  let drawing = false;
  let startX = 0, startY = 0;
  let freehandPath = [];
  let pendingTextPosition = null; // Store x, y when text tool is clicked
  let editingTextAnnotation = null; // Store annotation being edited
  
  // Drag state variables
  let dragging = false;
  let draggedAnnotation = null;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let originalAnnotationX = 0;
  let originalAnnotationY = 0;
  let originalFreehandPath = null; // Store original path for freehand annotations
  
  // Color picker setup
  const colorButtons = document.querySelectorAll('.color-btn');
  colorButtons.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const color = btn.getAttribute('data-color');
      colorInput.value = color;
      // Save selected color to sessionStorage
      if (typeof(Storage) !== "undefined") {
        sessionStorage.setItem('selectedColor', color);
      }
      // Set white background, colored border, and colored icon
      colorPickerBtn.style.backgroundColor = '#FFFFFF';
      colorPickerBtn.style.border = `1px solid ${color}`;
      const colorPickerIcon = document.getElementById('color-picker-icon');
      if (colorPickerIcon) {
        colorPickerIcon.style.color = color;
      }
      // Update active tool button color
      updateActiveToolColor();
      // Close dropdown
      const dropdown = document.getElementById('color-picker-container');
      dropdown.classList.remove('is-active');
    });
  });
  
  // Helper function to convert hex to RGB
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }
  
  // Initialize color picker button
  if (colorPickerBtn) {
    // Restore color from sessionStorage if available, otherwise use colorInput default
    const savedColor = (typeof(Storage) !== "undefined") ? sessionStorage.getItem('selectedColor') : null;
    const initialColor = savedColor || colorInput.value;
    
    // Update colorInput value if we restored from sessionStorage
    if (savedColor) {
      colorInput.value = savedColor;
    }
    
    // Set color picker button styling
    colorPickerBtn.style.backgroundColor = '#FFFFFF';
    colorPickerBtn.style.border = `1px solid ${initialColor}`;
    const colorPickerIcon = document.getElementById('color-picker-icon');
    if (colorPickerIcon) {
      colorPickerIcon.style.color = initialColor;
    }
    
    colorPickerBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const dropdown = document.getElementById('color-picker-container');
      dropdown.classList.toggle('is-active');
    });
  }
  
  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    const dropdown = document.getElementById('color-picker-container');
    if (!dropdown.contains(e.target)) {
      dropdown.classList.remove('is-active');
    }
  });

  function setActiveTool(selectedTool) {
    // Prevent selecting Move or Delete tools if there are no annotations
    if ((selectedTool === 'move' || selectedTool === 'delete') && (!existing || existing.length === 0)) {
      selectedTool = 'rect'; // Fallback to rectangle
    }
    
    tool = selectedTool;
    // Save the selected tool to sessionStorage so it persists across page navigation
    if (typeof(Storage) !== "undefined") {
      sessionStorage.setItem('selectedTool', selectedTool);
    }
    // Remove active class and add outlined class to all buttons, reset their styles
    [toolRectBtn, toolTextBtn, toolLineBtn, toolFreehandBtn, toolMoveBtn, deleteBtn].forEach(btn => {
      if (btn) {
        btn.classList.remove('is-active');
        btn.classList.add('is-outlined');
        // Reset to default outlined style
        btn.style.backgroundColor = '';
        btn.style.color = '';
        btn.style.borderColor = '';
      }
    });
    
    // Get the current selected color
    const selectedColor = colorInput.value;
    
    // Add active class and remove outlined class from selected button, set its color
    let activeBtn = null;
    if (tool === 'rect') {
      activeBtn = toolRectBtn;
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'text') {
      activeBtn = toolTextBtn;
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'line') {
      activeBtn = toolLineBtn;
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'freehand') {
      activeBtn = toolFreehandBtn;
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'move') {
      activeBtn = toolMoveBtn;
      canvas.style.cursor = 'move';
    } else if (tool === 'delete') {
      activeBtn = deleteBtn;
      canvas.style.cursor = 'pointer';
    }
    
    if (activeBtn) {
      activeBtn.classList.add('is-active');
      activeBtn.classList.remove('is-outlined');
      // Set background color - use selected color for all buttons except Delete and Move
      if (tool === 'delete' || tool === 'move') {
        // Delete and Move buttons stay black
        activeBtn.style.backgroundColor = '#000000';
        activeBtn.style.color = '#FFFFFF';
      } else {
        // Other buttons use selected color
        activeBtn.style.backgroundColor = selectedColor;
        // Set text color based on brightness for readability
        const rgb = hexToRgb(selectedColor);
        if (rgb) {
          const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
          activeBtn.style.color = brightness > 128 ? '#000000' : '#FFFFFF';
        } else {
          activeBtn.style.color = '#FFFFFF';
        }
      }
    }
  }
  
  // Function to update the active button's color when color changes
  function updateActiveToolColor() {
    const selectedColor = colorInput.value;
    const activeBtn = [toolRectBtn, toolTextBtn, toolLineBtn, toolFreehandBtn, toolMoveBtn, deleteBtn].find(btn => 
      btn && btn.classList.contains('is-active')
    );
    
    if (activeBtn) {
      // Don't update Delete or Move buttons - they stay black
      if (activeBtn === deleteBtn || activeBtn === toolMoveBtn) {
        return;
      }
      
      activeBtn.style.backgroundColor = selectedColor;
      const rgb = hexToRgb(selectedColor);
      if (rgb) {
        const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        activeBtn.style.color = brightness > 128 ? '#000000' : '#FFFFFF';
      } else {
        activeBtn.style.color = '#FFFFFF';
      }
    }
  }

  toolRectBtn.onclick = () => setActiveTool('rect');
  toolTextBtn.onclick = () => setActiveTool('text');
  toolLineBtn.onclick = () => setActiveTool('line');
  toolFreehandBtn.onclick = () => setActiveTool('freehand');
  toolMoveBtn.onclick = () => setActiveTool('move');
  deleteBtn.onclick = () => setActiveTool('delete');
  
  // Set initial active tool - restore from sessionStorage if available
  const savedTool = (typeof(Storage) !== "undefined") ? sessionStorage.getItem('selectedTool') : null;
  // If no saved tool, default to Rectangle; otherwise use saved tool
  const initialTool = savedTool || 'rect';
  setActiveTool(initialTool);
  
  // Initialize Move button state based on existing annotations
  updateMoveButtonState();

  function resizeCanvasToImage() {
    // Ensure image is loaded and has dimensions
    if (img.clientWidth > 0 && img.clientHeight > 0) {
      canvas.width = img.clientWidth;
      canvas.height = img.clientHeight;
      redraw();
    } else {
      // If image not ready, wait a bit and try again
      setTimeout(resizeCanvasToImage, 50);
    }
  }
  img.addEventListener('load', resizeCanvasToImage);
  window.addEventListener('resize', resizeCanvasToImage);
  // Use requestAnimationFrame to ensure DOM is ready
  if (img.complete) {
    requestAnimationFrame(() => {
      requestAnimationFrame(resizeCanvasToImage);
    });
  } else {
    // Also check periodically in case load event doesn't fire
    const checkInterval = setInterval(() => {
      if (img.complete && img.clientWidth > 0) {
        clearInterval(checkInterval);
        resizeCanvasToImage();
      }
    }, 100);
    // Clear interval after 5 seconds to avoid infinite checking
    setTimeout(() => clearInterval(checkInterval), 5000);
  }
  
  // Inline text input functions
  function showInlineTextInput(x, y, annotationToEdit = null, event = null) {
    if (!inlineTextInput || !inlineTextContainer) return;
    
    editingTextAnnotation = annotationToEdit;
    
    // Get screen coordinates - always convert from canvas coordinates for accuracy
    const canvasRect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / canvasRect.width;
    const scaleY = canvas.height / canvasRect.height;
    
    let screenX, screenY;
    if (annotationToEdit) {
      // Editing existing annotation - preserve line breaks
      inlineTextInput.value = annotationToEdit.text || '';
      pendingTextPosition = { x: annotationToEdit.x, y: annotationToEdit.y };
      // Position at annotation location
      screenX = canvasRect.left + (annotationToEdit.x / scaleX);
      screenY = canvasRect.top + (annotationToEdit.y / scaleY);
    } else {
      // Creating new annotation
      inlineTextInput.value = '';
      pendingTextPosition = { x, y };
      // Position at click location
      screenX = canvasRect.left + (x / scaleX);
      screenY = canvasRect.top + (y / scaleY);
    }
    
    // Position container so bottom-left is at the click point
    // Use bottom positioning to align with click point
    inlineTextContainer.style.left = screenX + 'px';
    inlineTextContainer.style.bottom = (window.innerHeight - screenY) + 'px';
    inlineTextContainer.style.display = 'flex';
    inlineTextContainer.style.alignItems = 'flex-end';
    
    // Reset textarea height to auto to recalculate
    inlineTextInput.style.height = 'auto';
    inlineTextInput.style.height = inlineTextInput.scrollHeight + 'px';
    
    // Focus and select text
    requestAnimationFrame(() => {
      inlineTextInput.focus();
      if (annotationToEdit && inlineTextInput.value) {
        inlineTextInput.select();
      }
    });
  }
  
  function hideInlineTextInput() {
    if (!inlineTextInput || !inlineTextContainer) return;
    inlineTextContainer.style.display = 'none';
    pendingTextPosition = null;
    editingTextAnnotation = null;
    inlineTextInput.value = '';
    inlineTextInput.style.height = 'auto';
  }
  
  function submitInlineText() {
    const txt = inlineTextInput.value; // Don't trim - preserve line breaks and whitespace
    
    if (!txt || !txt.trim()) {
      // If editing and text is empty, delete the annotation
      if (editingTextAnnotation) {
        deleteAnnotation(editingTextAnnotation.id);
      }
      hideInlineTextInput();
      return;
    }
    
    if (!pendingTextPosition) {
      hideInlineTextInput();
      return;
    }
    
    let x = pendingTextPosition.x;
    let y = pendingTextPosition.y;
    
    // Calculate text dimensions for multiline text
    ctx.font = '16px sans-serif';
    const lineHeight = 18;
    const lines = txt.split('\n');
    
    // Measure each line to find the maximum width
    let maxLineWidth = 0;
    for (let i = 0; i < lines.length; i++) {
      const metrics = ctx.measureText(lines[i]);
      maxLineWidth = Math.max(maxLineWidth, metrics.width);
    }
    
    const textWidth = maxLineWidth;
    const textHeight = lines.length * lineHeight;
    
    // Adjust x slightly to the left for better alignment
    x = x - 1;
    
    // Adjust y so that the vertical middle of the first line aligns with the click point
    // fillText draws with baseline at y
    // For the first line, we need to position the baseline so the middle of the line is at clickY
    // The middle of the first line = baseline - (lineHeight/2 - offset from baseline to middle)
    // We can use actualBoundingBoxAscent to find the height above baseline
    const firstLineMetrics = ctx.measureText(lines[0] || '');
    const actualBoundingBoxAscent = firstLineMetrics.actualBoundingBoxAscent || 13; // Typical for 16px font
    const actualBoundingBoxDescent = firstLineMetrics.actualBoundingBoxDescent || 3;
    
    // The middle of the first line is at: baseline - (lineHeight/2 - (ascent - lineHeight/2))
    // Simplified: middle = baseline - (lineHeight/2) + (ascent - lineHeight/2)
    // Actually, let's think: the line goes from (baseline - ascent) to (baseline + descent)
    // The middle would be at: baseline - ascent + (ascent + descent)/2 = baseline - (ascent - descent)/2
    // But lineHeight is typically larger than (ascent + descent)
    // For 16px font: ascent ~13px, descent ~3px, lineHeight ~18px
    // So the middle of the line (considering lineHeight) is at: baseline - lineHeight/2 + some offset
    // The offset accounts for the fact that the baseline is not at the middle
    
    // Calculate the middle of the first line relative to baseline
    // Middle of line = top of line + lineHeight/2
    // Top of line = baseline - ascent
    // So: middle = baseline - ascent + lineHeight/2
    // If we want middle at clickY: baseline = clickY + ascent - lineHeight/2
    const middleOffset = actualBoundingBoxAscent - (lineHeight / 2);
    y = y + middleOffset;
    
    if (editingTextAnnotation) {
      // Update existing annotation
      updateAnnotationPosition(editingTextAnnotation.id, {
        kind: 'text',
        x: x,
        y: y,
        w: textWidth,
        h: textHeight,
        text: txt, // Preserve line breaks
        color: editingTextAnnotation.color // Keep original color
      });
    } else {
      // Create new annotation
      saveAnnotation({ 
        kind: 'text', 
        x: x, 
        y: y, 
        w: textWidth,
        h: textHeight,
        text: txt, // Preserve line breaks
        color: colorInput.value 
      });
    }
    
    hideInlineTextInput();
  }
  
  // Inline text input event handlers
  if (inlineTextInput) {
    // Auto-resize textarea as user types
    inlineTextInput.addEventListener('input', () => {
      inlineTextInput.style.height = 'auto';
      inlineTextInput.style.height = inlineTextInput.scrollHeight + 'px';
    });
    
    inlineTextInput.addEventListener('keydown', (e) => {
      // Command-Enter (Mac) or Ctrl-Enter (Windows) to save
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        submitInlineText();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        hideInlineTextInput();
      }
      // Regular Enter key creates a new line (default textarea behavior)
    });
    
    // Save button click handler
    if (inlineTextSaveBtn) {
      inlineTextSaveBtn.addEventListener('click', (e) => {
        e.preventDefault();
        submitInlineText();
      });
    }
    
    // Don't auto-save on blur - user must explicitly save with button or Cmd/Ctrl-Enter
    // But still hide if empty when clicking outside
    inlineTextInput.addEventListener('blur', () => {
      setTimeout(() => {
        if (inlineTextContainer && inlineTextContainer.style.display === 'block') {
          // Only hide if empty, otherwise keep it visible for user to save
          if (!inlineTextInput.value || !inlineTextInput.value.trim()) {
            hideInlineTextInput();
          }
        }
      }, 200);
    });
  }

  function drawAnnotation(a) {
    const color = a.color || '#000000';
    ctx.strokeStyle = color;
    // Increased transparency: 15 hex = ~8% opacity (was 40 = 25% opacity)
    ctx.fillStyle = a.kind === 'rect' ? `${color}15` : color;
    ctx.lineWidth = 2;

    if (a.kind === 'rect') {
      ctx.beginPath();
      ctx.rect(a.x, a.y, a.w, a.h);
      ctx.fill();
      ctx.stroke();
    } else if (a.kind === 'text') {
      ctx.font = '16px sans-serif';
      ctx.fillStyle = color;
      
      if (a.text) {
        // No word wrapping - only respect explicit line breaks
        const lineHeight = 18;
        let y = a.y;
        
        // Split by line breaks and render each line as-is
        const lines = a.text.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], a.x, y);
          y += lineHeight;
        }
      }
    } else if (a.kind === 'line') {
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(a.x + a.w, a.y + a.h);
      ctx.stroke();
    } else if (a.kind === 'freehand') {
      // Draw freehand path from stored points
      if (a.text) {
        try {
          const path = JSON.parse(a.text);
          if (Array.isArray(path) && path.length > 0) {
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
              ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
          }
        } catch (e) {
          console.error('Error parsing freehand path:', e);
        }
      }
    }
  }

  function redraw() {
    // Ensure canvas is properly sized before drawing
    if (canvas.width !== img.clientWidth || canvas.height !== img.clientHeight) {
      if (img.clientWidth > 0 && img.clientHeight > 0) {
        canvas.width = img.clientWidth;
        canvas.height = img.clientHeight;
      } else {
        // Canvas not ready, skip drawing
        return;
      }
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    existing.forEach(drawAnnotation);
    // Update Move button state after redraw
    updateMoveButtonState();
  }

  function updateMoveButtonState() {
    // Show/hide Move button based on whether there are annotations on the page
    if (toolMoveBtn) {
      if (existing && existing.length > 0) {
        toolMoveBtn.style.display = '';
      } else {
        toolMoveBtn.style.display = 'none';
        // If Move tool is currently selected and there are no annotations, switch to a different tool
        if (tool === 'move') {
          setActiveTool('rect');
        }
      }
    }
    // If Delete tool is currently selected and there are no annotations, switch to a different tool
    if (deleteBtn && (!existing || existing.length === 0)) {
      if (tool === 'delete') {
        setActiveTool('rect');
      }
    }
  }

  function getCanvasCoordinates(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  canvas.addEventListener('mousedown', (e) => {
    // Prevent triggering canvas actions when clicking on color picker or inline text input
    const target = e.target;
    if (target.closest('#color-picker-container') || target === inlineTextInput || target === inlineTextSaveBtn || target.closest('#inline-text-container')) {
      return;
    }
    
    // Check if click is within toolbar area
    const toolbar = document.querySelector('.toolbar');
    if (toolbar && toolbar.contains(target)) {
      return;
    }
    
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      drawing = true;
      freehandPath = [{x, y}];
      // Start drawing immediately
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(x, y);
    } else if (tool === 'rect' || tool === 'line') {
      drawing = true;
      startX = x;
      startY = y;
    } else if (tool === 'text') {
      // Don't create new text if inline input is already visible
      if (inlineTextContainer && inlineTextContainer.style.display === 'block') {
        return;
      }
      // Show inline text input (pass event for accurate positioning)
      showInlineTextInput(x, y, null, e);
    } else if (tool === 'move') {
      // Check if clicking on an existing annotation
      const id = hitTest(x, y);
      if (id != null) {
        // Find the annotation
        const ann = existing.find(a => a.id === id);
        if (ann) {
          dragging = true;
          draggedAnnotation = ann;
          // Store original position
          originalAnnotationX = ann.x;
          originalAnnotationY = ann.y;
          // Calculate offset from click point to annotation origin
          dragOffsetX = x - ann.x;
          dragOffsetY = y - ann.y;
          // For freehand, store original path
          if (ann.kind === 'freehand' && ann.text) {
            try {
              originalFreehandPath = JSON.parse(ann.text);
            } catch (e) {
              console.error('Error parsing freehand path on drag start:', e);
              originalFreehandPath = null;
            }
          } else {
            originalFreehandPath = null;
          }
        }
      }
    } else if (tool === 'delete') {
      const id = hitTest(x, y);
      if (id != null) deleteAnnotation(id);
    }
  });

  // Touch events for stylus/mobile support
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      drawing = true;
      freehandPath = [{x, y}];
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(x, y);
    } else if (tool === 'rect' || tool === 'line') {
      drawing = true;
      startX = x;
      startY = y;
    } else if (tool === 'text') {
      // Don't create new text if inline input is already visible
      if (inlineTextContainer && inlineTextContainer.style.display === 'block') {
        return;
      }
      // Show inline text input (pass event for accurate positioning)
      showInlineTextInput(x, y, null, e);
    } else if (tool === 'move') {
      // Check if clicking on an existing annotation
      const id = hitTest(x, y);
      if (id != null) {
        // Find the annotation
        const ann = existing.find(a => a.id === id);
        if (ann) {
          dragging = true;
          draggedAnnotation = ann;
          // Store original position
          originalAnnotationX = ann.x;
          originalAnnotationY = ann.y;
          // Calculate offset from click point to annotation origin
          dragOffsetX = x - ann.x;
          dragOffsetY = y - ann.y;
          // For freehand, store original path
          if (ann.kind === 'freehand' && ann.text) {
            try {
              originalFreehandPath = JSON.parse(ann.text);
            } catch (e) {
              originalFreehandPath = null;
            }
          } else {
            originalFreehandPath = null;
          }
        }
      }
    } else if (tool === 'delete') {
      const id = hitTest(x, y);
      if (id != null) deleteAnnotation(id);
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    // Handle dragging annotations
    if (dragging && draggedAnnotation) {
      const coords = getCanvasCoordinates(e);
      const newX = coords.x - dragOffsetX;
      const newY = coords.y - dragOffsetY;
      
      // For freehand annotations, update all path points in real-time
      if (draggedAnnotation.kind === 'freehand' && originalFreehandPath) {
        try {
          // Calculate delta from original bounding box position
          const deltaX = newX - originalAnnotationX;
          const deltaY = newY - originalAnnotationY;
          
          // Update all path points from original path (not current path)
          const updatedPath = originalFreehandPath.map(p => ({
            x: p.x + deltaX,
            y: p.y + deltaY
          }));
          
          // Update bounding box
          const xs = updatedPath.map(p => p.x);
          const ys = updatedPath.map(p => p.y);
          const minX = Math.min(...xs);
          const minY = Math.min(...ys);
          const maxX = Math.max(...xs);
          const maxY = Math.max(...ys);
          
          // Update annotation
          draggedAnnotation.x = minX;
          draggedAnnotation.y = minY;
          draggedAnnotation.w = maxX - minX;
          draggedAnnotation.h = maxY - minY;
          draggedAnnotation.text = JSON.stringify(updatedPath);
        } catch (e) {
          console.error('Error updating freehand path during drag:', e);
          // Fallback: just update position
          draggedAnnotation.x = newX;
          draggedAnnotation.y = newY;
        }
      } else {
        // For other annotation types, just update x, y
        draggedAnnotation.x = newX;
        draggedAnnotation.y = newY;
      }
      
      // Redraw canvas with updated position
      redraw();
      return;
    }
    
    if (!drawing) return;
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      freehandPath.push({x, y});
      ctx.lineTo(x, y);
      ctx.stroke();
    } else if (tool === 'rect' || tool === 'line') {
      redraw();
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      if (tool === 'rect') ctx.strokeRect(startX, startY, x - startX, y - startY);
      if (tool === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    }
  });

  // Touch move for stylus/mobile support
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    
    // Handle dragging annotations
    if (dragging && draggedAnnotation) {
      const coords = getCanvasCoordinates(e);
      const newX = coords.x - dragOffsetX;
      const newY = coords.y - dragOffsetY;
      
      // For freehand annotations, update all path points in real-time
      if (draggedAnnotation.kind === 'freehand' && originalFreehandPath) {
        try {
          // Calculate delta from original bounding box position
          const deltaX = newX - originalAnnotationX;
          const deltaY = newY - originalAnnotationY;
          
          // Update all path points from original path (not current path)
          const updatedPath = originalFreehandPath.map(p => ({
            x: p.x + deltaX,
            y: p.y + deltaY
          }));
          
          // Update bounding box
          const xs = updatedPath.map(p => p.x);
          const ys = updatedPath.map(p => p.y);
          const minX = Math.min(...xs);
          const minY = Math.min(...ys);
          const maxX = Math.max(...xs);
          const maxY = Math.max(...ys);
          
          // Update annotation
          draggedAnnotation.x = minX;
          draggedAnnotation.y = minY;
          draggedAnnotation.w = maxX - minX;
          draggedAnnotation.h = maxY - minY;
          draggedAnnotation.text = JSON.stringify(updatedPath);
        } catch (e) {
          console.error('Error updating freehand path during drag:', e);
          // Fallback: just update position
          draggedAnnotation.x = newX;
          draggedAnnotation.y = newY;
        }
      } else {
        // For other annotation types, just update x, y
        draggedAnnotation.x = newX;
        draggedAnnotation.y = newY;
      }
      
      // Redraw canvas with updated position
      redraw();
      return;
    }
    
    if (!drawing) return;
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      freehandPath.push({x, y});
      ctx.lineTo(x, y);
      ctx.stroke();
    } else if (tool === 'rect' || tool === 'line') {
      redraw();
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      if (tool === 'rect') ctx.strokeRect(startX, startY, x - startX, y - startY);
      if (tool === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    // Handle drag end
    if (dragging && draggedAnnotation) {
      const coords = getCanvasCoordinates(e);
      const newX = coords.x - dragOffsetX;
      const newY = coords.y - dragOffsetY;
      
      // For freehand annotations, update all path points
      if (draggedAnnotation.kind === 'freehand' && originalFreehandPath) {
        try {
          // Calculate delta from original bounding box position
          const deltaX = newX - originalAnnotationX;
          const deltaY = newY - originalAnnotationY;
          
          // Update all path points from original path (not current path)
          const updatedPath = originalFreehandPath.map(p => ({
            x: p.x + deltaX,
            y: p.y + deltaY
          }));
          
          // Update bounding box
          const xs = updatedPath.map(p => p.x);
          const ys = updatedPath.map(p => p.y);
          const minX = Math.min(...xs);
          const minY = Math.min(...ys);
          const maxX = Math.max(...xs);
          const maxY = Math.max(...ys);
          
          // Update annotation
          draggedAnnotation.x = minX;
          draggedAnnotation.y = minY;
          draggedAnnotation.w = maxX - minX;
          draggedAnnotation.h = maxY - minY;
          draggedAnnotation.text = JSON.stringify(updatedPath);
          
          // Save to database
          updateAnnotationPosition(draggedAnnotation.id, {
            kind: 'freehand',
            x: minX,
            y: minY,
            w: maxX - minX,
            h: maxY - minY,
            text: JSON.stringify(updatedPath)
          });
        } catch (e) {
          console.error('Error updating freehand path:', e);
          // Fallback: just update position
          updateAnnotationPosition(draggedAnnotation.id, {
            x: newX,
            y: newY
          });
        }
      } else {
        // For other annotation types, just update x, y
        updateAnnotationPosition(draggedAnnotation.id, {
          x: newX,
          y: newY
        });
      }
      
      // Reset drag state
      dragging = false;
      draggedAnnotation = null;
      dragOffsetX = 0;
      dragOffsetY = 0;
      originalAnnotationX = 0;
      originalAnnotationY = 0;
      originalFreehandPath = null;
      return;
    }
    
    if (!drawing) return;
    
    if (tool === 'freehand') {
      if (freehandPath.length > 1) {
        // Calculate bounding box for freehand drawing
        const xs = freehandPath.map(p => p.x);
        const ys = freehandPath.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        
        const payload = {
          kind: 'freehand',
          x: minX,
          y: minY,
          w: maxX - minX,
          h: maxY - minY,
          text: JSON.stringify(freehandPath),
          color: colorInput.value
        };
        saveAnnotation(payload);
      }
      freehandPath = [];
    } else if (tool === 'rect' || tool === 'line') {
      const coords = getCanvasCoordinates(e);
      const endX = coords.x;
      const endY = coords.y;
      const w = endX - startX;
      const h = endY - startY;

      if (Math.abs(w) < 3 && Math.abs(h) < 3) {
        drawing = false;
        return;
      }
      const payload = { kind: tool, x: startX, y: startY, w, h, color: colorInput.value };
      saveAnnotation(payload);
    }
    
    drawing = false;
  });

  // Double-click to edit text annotations
  canvas.addEventListener('dblclick', (e) => {
    // Prevent triggering canvas actions when clicking on color picker or inline text input
    const target = e.target;
    if (target.closest('#color-picker-container') || target === inlineTextInput || target === inlineTextSaveBtn || target.closest('#inline-text-container')) {
      return;
    }
    
    // Check if click is within toolbar area
    const toolbar = document.querySelector('.toolbar');
    if (toolbar && toolbar.contains(target)) {
      return;
    }
    
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;
    
    // Check if double-click is on a text annotation
    const id = hitTest(x, y);
    if (id != null) {
      const ann = existing.find(a => a.id === id);
      if (ann && ann.kind === 'text') {
        // Show inline text input with existing text for editing
        showInlineTextInput(x, y, ann, e);
      }
    }
  });

  // Touch end for stylus/mobile support
  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    
    // Handle drag end
    if (dragging && draggedAnnotation) {
      // For touchend, try to get coordinates from changedTouches, or use current annotation position
      let coords;
      if (e.changedTouches && e.changedTouches.length > 0) {
        coords = getCanvasCoordinates(e.changedTouches[0]);
      } else {
        // Fallback: use current annotation position
        coords = { x: draggedAnnotation.x + dragOffsetX, y: draggedAnnotation.y + dragOffsetY };
      }
      const newX = coords.x - dragOffsetX;
      const newY = coords.y - dragOffsetY;
      
      // For freehand annotations, update all path points
      if (draggedAnnotation.kind === 'freehand' && originalFreehandPath) {
        try {
          // Calculate delta from original bounding box position
          const deltaX = newX - originalAnnotationX;
          const deltaY = newY - originalAnnotationY;
          
          // Update all path points from original path (not current path)
          const updatedPath = originalFreehandPath.map(p => ({
            x: p.x + deltaX,
            y: p.y + deltaY
          }));
          
          // Update bounding box
          const xs = updatedPath.map(p => p.x);
          const ys = updatedPath.map(p => p.y);
          const minX = Math.min(...xs);
          const minY = Math.min(...ys);
          const maxX = Math.max(...xs);
          const maxY = Math.max(...ys);
          
          // Update annotation
          draggedAnnotation.x = minX;
          draggedAnnotation.y = minY;
          draggedAnnotation.w = maxX - minX;
          draggedAnnotation.h = maxY - minY;
          draggedAnnotation.text = JSON.stringify(updatedPath);
          
          // Save to database
          updateAnnotationPosition(draggedAnnotation.id, {
            kind: 'freehand',
            x: minX,
            y: minY,
            w: maxX - minX,
            h: maxY - minY,
            text: JSON.stringify(updatedPath)
          });
        } catch (e) {
          console.error('Error updating freehand path:', e);
          // Fallback: just update position
          updateAnnotationPosition(draggedAnnotation.id, {
            x: newX,
            y: newY
          });
        }
      } else {
        // For other annotation types, just update x, y
        updateAnnotationPosition(draggedAnnotation.id, {
          x: newX,
          y: newY
        });
      }
      
      // Reset drag state
      dragging = false;
      draggedAnnotation = null;
      dragOffsetX = 0;
      dragOffsetY = 0;
      originalAnnotationX = 0;
      originalAnnotationY = 0;
      originalFreehandPath = null;
      return;
    }
    
    if (!drawing) return;
    
    if (tool === 'freehand') {
      if (freehandPath.length > 1) {
        const xs = freehandPath.map(p => p.x);
        const ys = freehandPath.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        
        const payload = {
          kind: 'freehand',
          x: minX,
          y: minY,
          w: maxX - minX,
          h: maxY - minY,
          text: JSON.stringify(freehandPath),
          color: colorInput.value
        };
        saveAnnotation(payload);
      }
      freehandPath = [];
    } else if (tool === 'rect' || tool === 'line') {
      const coords = getCanvasCoordinates(e);
      const endX = coords.x;
      const endY = coords.y;
      const w = endX - startX;
      const h = endY - startY;

      if (Math.abs(w) < 3 && Math.abs(h) < 3) {
        drawing = false;
        return;
      }
      const payload = { kind: tool, x: startX, y: startY, w, h, color: colorInput.value };
      saveAnnotation(payload);
    }
    
    drawing = false;
  });

  function saveAnnotation(payload) {
    fetch(`{{ url_for('annotate', page_id=page.id) }}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }).then(r => r.json()).then(resp => {
      if (resp.id) {
        // Add to existing array and redraw
        existing.push(resp);
        redraw();
        // Update Move button state (redraw already calls it, but being explicit)
        updateMoveButtonState();
      }
    }).catch(err => {
      console.error('Error saving annotation:', err);
      alert('Failed to save annotation');
    });
  }

  function deleteAnnotation(id) {
    fetch(`${window.BASE_PATH || ''}/annotations/${id}`, { method: 'DELETE' })
      .then(r => r.json())
      .then(resp => { 
        if (resp.status === 'success') {
          // Remove from local array
          existing = existing.filter(a => a.id !== id);
          // Redraw canvas
          redraw();
          // Update Move button state (redraw already calls it, but being explicit)
          updateMoveButtonState();
          // Keep Delete tool selected (don't change tool)
        }
      });
  }

  function updateAnnotationPosition(id, data) {
    fetch(`${window.BASE_PATH || ''}/annotations/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    })
      .then(r => r.json())
      .then(resp => {
        if (resp.status === 'success' || resp.id) {
          // Update local annotation with response data (which includes all updated fields)
          const index = existing.findIndex(a => a.id === id);
          if (index !== -1) {
            // Use response data if available, otherwise fall back to data we sent
            if (resp.id) {
              existing[index] = {
                id: resp.id,
                kind: resp.kind || existing[index].kind,
                x: resp.x !== undefined ? resp.x : existing[index].x,
                y: resp.y !== undefined ? resp.y : existing[index].y,
                w: resp.w !== undefined ? resp.w : existing[index].w,
                h: resp.h !== undefined ? resp.h : existing[index].h,
                text: resp.text !== undefined ? resp.text : existing[index].text,
                color: resp.color !== undefined ? resp.color : existing[index].color
              };
            } else {
              // Fallback: merge with data we sent
              existing[index] = { ...existing[index], ...data };
            }
            // Redraw canvas
            redraw();
          }
        }
      })
      .catch(err => {
        console.error('Error updating annotation:', err);
        alert('Failed to save annotation');
      });
  }

  function hitTest(x, y) {
    for (let i = existing.length - 1; i >= 0; i--) {
      const a = existing[i];
      if (a.kind === 'rect') {
        if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) return a.id;
      } else if (a.kind === 'text') {
        // Use stored width/height if available, otherwise calculate
        const w = a.w || (10 + (a.text ? a.text.length * 8 : 20));
        const h = a.h || 20;
        
        // For text, a.y is the baseline of the first line
        // The stored h is the total height (numLines * lineHeight = 18 * numLines)
        // Text is positioned so the middle of the first line aligns with the click point
        // 
        // The baseline is offset from the middle: baseline = middle + (lineHeight/2 - ascent)
        // Top of first line: baseline - ascent = middle - lineHeight/2
        // Bottom of last line: baseline + (numLines - 1) * lineHeight + descent
        //   = middle - lineHeight/2 + ascent + (numLines - 1) * lineHeight + descent
        //   â‰ˆ middle - lineHeight/2 + h (since h = numLines * lineHeight)
        //
        // Since middle was at clickY, and baseline is at a.y:
        // Top of text: a.y - ascent â‰ˆ a.y - lineHeight/2
        // Bottom of text: a.y - lineHeight/2 + h
        const lineHeight = 18;
        const ascent = 13; // Typical ascent for 16px font
        const topY = a.y - ascent;
        const bottomY = a.y - lineHeight / 2 + h;
        
        // Check if point is within the bounding box (with small padding for easier clicking)
        if (x >= a.x - 5 && x <= a.x + w + 5 && y >= topY - 2 && y <= bottomY + 2) return a.id;
      } else if (a.kind === 'line') {
        const dist = Math.abs((a.h)*(x - a.x) - (a.w)*(y - a.y)) / Math.sqrt(a.h*a.h + a.w*a.w);
        if (dist < 5) return a.id;
      } else if (a.kind === 'freehand') {
        // Check if point is near any segment of the freehand path
        if (a.text) {
          try {
            const path = JSON.parse(a.text);
            if (Array.isArray(path) && path.length > 0) {
              // Check if point is within bounding box first (quick check)
              // Handle cases where w or h might be missing
              const w = a.w || 0;
              const h = a.h || 0;
              if (w > 0 && h > 0 && x >= a.x && x <= a.x + w && y >= a.y && y <= a.y + h) {
                // Check distance to path segments
                for (let j = 0; j < path.length - 1; j++) {
                  const p1 = path[j];
                  const p2 = path[j + 1];
                  if (p1 && p2 && typeof p1.x === 'number' && typeof p1.y === 'number' && 
                      typeof p2.x === 'number' && typeof p2.y === 'number') {
                    const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < 8) return a.id; // 8px threshold for freehand
                  }
                }
              } else {
                // If bounding box is invalid, check path segments directly
                for (let j = 0; j < path.length - 1; j++) {
                  const p1 = path[j];
                  const p2 = path[j + 1];
                  if (p1 && p2 && typeof p1.x === 'number' && typeof p1.y === 'number' && 
                      typeof p2.x === 'number' && typeof p2.y === 'number') {
                    const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < 8) return a.id; // 8px threshold for freehand
                  }
                }
              }
            }
          } catch (e) {
            console.error('Error parsing freehand path in hitTest:', e);
          }
        }
      }
    }
    return null;
  }

  function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    if (lenSq !== 0) param = dot / lenSq;
    
    let xx, yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Emoji selection
  const panel = document.getElementById('emoji-panel');
  if (panel) {
    function setSelectedEmoji(emoji) {
      document.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.classList.toggle('is-selected', btn.dataset.emoji === emoji);
      });
    }
    if (currentEmoji) setSelectedEmoji(currentEmoji);
    
    panel.addEventListener('click', (e) => {
      const btn = e.target.closest('.emoji-btn');
      if (!btn) return;
      const emoji = btn.dataset.emoji;
      const newEmoji = emoji === currentEmoji ? null : emoji;
      fetch(`${window.BASE_PATH || ''}/page/${pageId}/reaction`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({emoji: newEmoji})
      }).then(r => {
        if (!r.ok) {
          throw new Error(`HTTP ${r.status}`);
        }
        return r.json().catch(() => {
          // If JSON parsing fails, but status was OK, assume success
          return {ok: true};
        });
      }).then(resp => {
        // Update UI regardless of response format if HTTP status was OK
        currentEmoji = newEmoji;
        setSelectedEmoji(newEmoji);
      }).catch(err => {
        console.error('Error saving reaction:', err);
        alert('Failed to save reaction. Please try again.');
      });
    });
  }

  // Function to draw annotation at full resolution
  function drawAnnotationAtFullRes(ctx, a, scaleX, scaleY) {
    const color = a.color || '#000000';
    ctx.strokeStyle = color;
    ctx.fillStyle = a.kind === 'rect' ? `${color}15` : color;
    ctx.lineWidth = 2 * scaleX; // Scale line width proportionally
    
    if (a.kind === 'rect') {
      const x = a.x * scaleX;
      const y = a.y * scaleY;
      const w = a.w * scaleX;
      const h = a.h * scaleY;
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.fill();
      ctx.stroke();
    } else if (a.kind === 'text') {
      // Scale font size proportionally
      const fontSize = Math.round(16 * scaleX);
      ctx.font = `${fontSize}px sans-serif`;
      ctx.fillStyle = color;
      
      if (a.text) {
        // No word wrapping - only respect explicit line breaks
        const lineHeight = Math.round(18 * scaleY);
        let y = a.y * scaleY;
        
        // Split by line breaks and render each line as-is
        const lines = a.text.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], a.x * scaleX, y);
          y += lineHeight;
        }
      }
    } else if (a.kind === 'line') {
      ctx.beginPath();
      ctx.moveTo(a.x * scaleX, a.y * scaleY);
      ctx.lineTo((a.x + a.w) * scaleX, (a.y + a.h) * scaleY);
      ctx.stroke();
    } else if (a.kind === 'freehand') {
      if (a.text) {
        try {
          const path = JSON.parse(a.text);
          if (Array.isArray(path) && path.length > 0) {
            ctx.beginPath();
            ctx.moveTo(path[0].x * scaleX, path[0].y * scaleY);
            for (let i = 1; i < path.length; i++) {
              ctx.lineTo(path[i].x * scaleX, path[i].y * scaleY);
            }
            ctx.stroke();
          }
        } catch (e) {
          console.error('Error parsing freehand path:', e);
        }
      }
    }
  }

  // Download PNG with annotations - render at full resolution
  function downloadAnnotatedPNG(event) {
    event.preventDefault();
    
    // Get the displayed image element
    const img = document.getElementById('page-img');
    if (!img) {
      alert('Image not found');
      return;
    }
    
    // Create a new canvas to combine image and annotations
    const downloadCanvas = document.createElement('canvas');
    
    // Load the full-resolution image
    const fullResImg = new Image();
    fullResImg.crossOrigin = 'anonymous'; // Handle CORS if needed
    
    fullResImg.onload = function() {
      // Set canvas to full image resolution
      downloadCanvas.width = fullResImg.naturalWidth;
      downloadCanvas.height = fullResImg.naturalHeight;
      
      const ctx = downloadCanvas.getContext('2d');
      
      // Draw the full-resolution image
      ctx.drawImage(fullResImg, 0, 0);
      
      // Calculate scale factor from displayed size to full resolution
      // CRITICAL: Use canvas dimensions, not img.clientWidth, because annotations are stored
      // relative to canvas.width/height (which may be rounded integers)
      const displayedWidth = canvas.width;
      const displayedHeight = canvas.height;
      const scaleX = fullResImg.naturalWidth / displayedWidth;
      const scaleY = fullResImg.naturalHeight / displayedHeight;
      
      // Redraw all annotations at full resolution
      existing.forEach(function(annotation) {
        drawAnnotationAtFullRes(ctx, annotation, scaleX, scaleY);
      });
      
      // Convert to blob and download
      downloadCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `{{ doc.filename|replace('.pdf', '') }}_page_{{ page.page_index + 1 }}_annotated.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };
    
    fullResImg.onerror = function() {
      // Fallback: capture at displayed resolution if full-res fails
      downloadCanvas.width = img.clientWidth;
      downloadCanvas.height = img.clientHeight;
      
      const ctx = downloadCanvas.getContext('2d');
      
      // Draw the displayed image
      ctx.drawImage(img, 0, 0);
      
      // Draw the annotation canvas
      ctx.drawImage(canvas, 0, 0);
      
      // Convert to blob and download
      downloadCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `{{ doc.filename|replace('.pdf', '') }}_page_{{ page.page_index + 1 }}_annotated.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };
    
    // Load the full-resolution image
    fullResImg.src = img.src;
  }

  // Function to generate annotated PNG for a page - uses EXACT same logic as downloadAnnotatedPNG
  // Returns: { dataUrl: string, width: number, height: number }
  function generateAnnotatedPNGForPage(pageImageUrl, annotations) {
    return new Promise((resolve, reject) => {
      // Check if this is the current page - if so, use exact same logic as downloadAnnotatedPNG
      const currentImg = document.getElementById('page-img');
      let displayedWidth, displayedHeight;
      
      // Normalize URLs for comparison - extract just the path part
      const normalizeUrl = (url) => {
        try {
          // Handle both absolute and relative URLs
          if (url.startsWith('http://') || url.startsWith('https://')) {
            const u = new URL(url);
            return u.pathname;
          } else {
            // Relative URL - extract path after removing query params
            const path = url.split('?')[0];
            // Remove any leading slashes and base path
            return path.replace(/^\/+/, '').replace(/^[^\/]+\//, '');
          }
        } catch {
          // Fallback: just extract the filename/path
          return url.split('?')[0].split('/').pop();
        }
      };
      
      const currentImgSrc = currentImg ? normalizeUrl(currentImg.src) : null;
      const targetImgSrc = normalizeUrl(pageImageUrl);
      
      // Also check if the URLs end with the same path (more robust comparison)
      const currentPath = currentImgSrc ? currentImgSrc.split('/').pop() : null;
      const targetPath = targetImgSrc ? targetImgSrc.split('/').pop() : null;
      const pathsMatch = currentPath && targetPath && currentPath === targetPath;
      const fullUrlsMatch = currentImgSrc === targetImgSrc;
      
      if (currentImg && (fullUrlsMatch || pathsMatch) && currentImg.clientWidth > 0) {
        // Same page - use canvas dimensions (annotations are stored relative to canvas, not img)
        // This is EXACTLY what downloadAnnotatedPNG does
        const currentCanvas = document.getElementById('annot-canvas');
        if (currentCanvas && currentCanvas.width > 0 && currentCanvas.height > 0) {
          displayedWidth = currentCanvas.width;
          displayedHeight = currentCanvas.height;
        } else {
          // Fallback to image dimensions if canvas not available
          displayedWidth = currentImg.clientWidth;
          displayedHeight = currentImg.clientHeight;
        }
        generatePNG();
      } else {
        // Different page - use the current page's display scale as a reference
        // This ensures consistent scaling across all pages
        const currentCanvas = document.getElementById('annot-canvas');
        let currentDisplayedWidth, currentDisplayedHeight;
        
        if (currentCanvas && currentCanvas.width > 0 && currentCanvas.height > 0) {
          // Use canvas dimensions if available
          currentDisplayedWidth = currentCanvas.width;
          currentDisplayedHeight = currentCanvas.height;
        } else if (currentImg && currentImg.clientWidth > 0) {
          // Fallback to image dimensions
          currentDisplayedWidth = currentImg.clientWidth;
          currentDisplayedHeight = currentImg.clientHeight;
        } else {
          // No reference available, need to measure
          currentDisplayedWidth = null;
          currentDisplayedHeight = null;
        }
        
        // Load the target image to get its natural dimensions
        const targetImg = new Image();
        targetImg.crossOrigin = 'anonymous';
        
        targetImg.onload = function() {
          if (currentDisplayedWidth && currentImg && currentImg.naturalWidth > 0) {
            // Calculate the display scale from the current page
            const currentDisplayScale = currentDisplayedWidth / currentImg.naturalWidth;
            
            // Apply the same scale to the target image
            displayedWidth = Math.round(targetImg.naturalWidth * currentDisplayScale);
            displayedHeight = Math.round(targetImg.naturalHeight * currentDisplayScale);
            
            generatePNG();
          } else {
            // Fallback: measure the target image directly
            const tempContainer = document.createElement('div');
            tempContainer.style.position = 'absolute';
            tempContainer.style.top = '-9999px';
            tempContainer.style.left = '-9999px';
            tempContainer.style.width = '66.666%';
            tempContainer.style.maxWidth = '66.666%';
            tempContainer.style.visibility = 'hidden';
            
            const tempWrapper = document.createElement('div');
            tempWrapper.style.position = 'relative';
            tempWrapper.style.display = 'inline-block';
            tempWrapper.style.width = '100%';
            
            const tempImg = document.createElement('img');
            tempImg.className = 'page-image';
            tempImg.style.width = '100%';
            tempImg.style.height = 'auto';
            tempImg.style.display = 'block';
            tempImg.crossOrigin = 'anonymous';
            tempImg.src = pageImageUrl;
            
            tempWrapper.appendChild(tempImg);
            tempContainer.appendChild(tempWrapper);
            document.body.appendChild(tempContainer);
            
            tempImg.onload = function() {
              void tempContainer.offsetWidth;
              void tempImg.offsetWidth;
              
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  displayedWidth = Math.round(tempImg.clientWidth);
                  displayedHeight = Math.round(tempImg.clientHeight);
                  
                  if (!displayedWidth || !displayedHeight) {
                    document.body.removeChild(tempContainer);
                    reject(new Error('Failed to get valid dimensions'));
                    return;
                  }
                  
                  document.body.removeChild(tempContainer);
                  generatePNG();
                });
              });
            };
            
            tempImg.onerror = function() {
              document.body.removeChild(tempContainer);
              reject(new Error('Failed to load image'));
            };
          }
        };
        
        targetImg.onerror = function() {
          reject(new Error('Failed to load target image: ' + pageImageUrl));
        };
        
        targetImg.src = pageImageUrl;
      }
      
      function generatePNG() {
        // Load the full-resolution image - EXACT same as downloadAnnotatedPNG
        const fullResImg = new Image();
        fullResImg.crossOrigin = 'anonymous';
        
        fullResImg.onload = function() {
          // Create canvas at full image resolution - EXACT same as downloadAnnotatedPNG
          const downloadCanvas = document.createElement('canvas');
          downloadCanvas.width = fullResImg.naturalWidth;
          downloadCanvas.height = fullResImg.naturalHeight;
          const ctx = downloadCanvas.getContext('2d');
          
          // Draw the full-resolution image
          ctx.drawImage(fullResImg, 0, 0);
          
          // Calculate scale factor - EXACT same as downloadAnnotatedPNG
          const scaleX = fullResImg.naturalWidth / displayedWidth;
          const scaleY = fullResImg.naturalHeight / displayedHeight;
          
          // Redraw all annotations at full resolution - EXACT same function
          if (annotations && annotations.length > 0) {
            annotations.forEach(function(annotation) {
              drawAnnotationAtFullRes(ctx, annotation, scaleX, scaleY);
            });
          }
          
          // Convert to data URL - EXACT same as downloadAnnotatedPNG
          // Return both the data URL and the exact canvas dimensions
          try {
            const dataUrl = downloadCanvas.toDataURL('image/png');
            if (dataUrl && dataUrl.startsWith('data:')) {
              resolve({
                dataUrl: dataUrl,
                width: downloadCanvas.width,
                height: downloadCanvas.height
              });
            } else {
              reject(new Error('Failed to generate PNG data URL'));
            }
          } catch (err) {
            reject(new Error('Failed to generate PNG: ' + err.message));
          }
        };
        
        fullResImg.onerror = function() {
          reject(new Error('Failed to load full-resolution image: ' + pageImageUrl));
        };
        
        fullResImg.src = pageImageUrl;
      }
    });
  }

  // Function to download entire document as PDF
  async function downloadDocumentPDF(event) {
    event.preventDefault();
    
    const btn = event.target;
    const originalText = btn.textContent;
    btn.disabled = true;
    btn.textContent = 'Generating PDF...';
    
    try {
      // Fetch all pages for this document
      const docResponse = await fetch(`${window.BASE_PATH || ''}/doc/{{ page.document_id }}`);
      const docText = await docResponse.text();
      
      // Parse page IDs from the HTML
      const pageIdRegex = /page\/(\d+)/g;
      const pageIds = [];
      let match;
      while ((match = pageIdRegex.exec(docText)) !== null) {
        pageIds.push(parseInt(match[1]));
      }
      
      // Remove duplicates
      const uniquePageIds = [...new Set(pageIds)];
      
      if (uniquePageIds.length === 0) {
        throw new Error('No pages found for document');
      }
      
      // Fetch all pages to get their indices and data
      const pagesWithData = await Promise.all(
        uniquePageIds.map(async (pageId) => {
          try {
            const response = await fetch(`${window.BASE_PATH || ''}/page/${pageId}.json`);
            const data = await response.json();
            return {
              id: pageId,
              page_index: data.page_index,
              image_url: data.image_url,
              annotations: data.annotations || []
            };
          } catch (e) {
            console.error(`Error fetching page ${pageId}:`, e);
            return null;
          }
        })
      );
      
      // Filter out nulls and sort by page_index
      const sortedPages = pagesWithData
        .filter(p => p !== null)
        .sort((a, b) => a.page_index - b.page_index);
      
      if (sortedPages.length === 0) {
        throw new Error('No pages found for document');
      }
      
      const { jsPDF } = window.jspdf;
      let pdf = null;
      const docFilename = '{{ doc.filename|replace(".pdf", "") }}';
      
      // Process each page
      for (let i = 0; i < sortedPages.length; i++) {
        const page = sortedPages[i];
        btn.textContent = `Processing page ${i + 1} of ${sortedPages.length}...`;
        
        // Generate annotated PNG using EXACT same logic as single-page download
        // Returns both data URL and exact dimensions
        const pagePNG = await generateAnnotatedPNGForPage(page.image_url, page.annotations);
        
        // Use the exact canvas dimensions from PNG generation (1:1 ratio - no scaling, no margins)
        // This ensures perfect alignment - these are the exact dimensions used when creating the PNG
        const imgWidthPt = pagePNG.width;
        const imgHeightPt = pagePNG.height;
        
        // Set PDF page size to match PNG exactly (no margins)
        if (i === 0) {
          pdf = new jsPDF({
            orientation: imgWidthPt > imgHeightPt ? 'landscape' : 'portrait',
            unit: 'pt',
            format: [imgWidthPt, imgHeightPt],
            compress: true
          });
          // Remove any default margins
          pdf.setPage(1);
        } else {
          pdf.addPage([imgWidthPt, imgHeightPt], imgWidthPt > imgHeightPt ? 'landscape' : 'portrait');
        }
        
        // Get current page and ensure no margins
        const currentPage = pdf.internal.getCurrentPageInfo().pageNumber;
        pdf.setPage(currentPage);
        
        // Add image to PDF at exact dimensions, starting at (0, 0) with no margins
        // Use the exact pixel dimensions - 1 pixel = 1 point for perfect alignment
        pdf.addImage(pagePNG.dataUrl, 'PNG', 0, 0, imgWidthPt, imgHeightPt, undefined, 'FAST');
      }
      
      // Save the PDF
      pdf.save(`${docFilename}_annotated.pdf`);
      
      btn.disabled = false;
      btn.textContent = originalText;
    } catch (error) {
      console.error('Error generating PDF:', error);
      alert('Error generating PDF: ' + error.message);
      btn.disabled = false;
      btn.textContent = originalText;
    }
  }

</script>
{% else %}
<script>
  // Download PNG function for teachers (no annotations, just the page image)
  function downloadAnnotatedPNG(event) {
    event.preventDefault();
    
    const img = document.getElementById('page-img');
    if (!img) {
      alert('Image not found');
      return;
    }
    
    // Create a canvas to capture the image
    const downloadCanvas = document.createElement('canvas');
    
    // Load the full-resolution image
    const fullResImg = new Image();
    fullResImg.crossOrigin = 'anonymous';
    
    fullResImg.onload = function() {
      // Set canvas to full image resolution
      downloadCanvas.width = fullResImg.naturalWidth;
      downloadCanvas.height = fullResImg.naturalHeight;
      
      const ctx = downloadCanvas.getContext('2d');
      ctx.drawImage(fullResImg, 0, 0);
      
      // Convert to blob and download
      downloadCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `{{ doc.filename|replace('.pdf', '') }}_page_{{ page.page_index + 1 }}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };
    
    fullResImg.onerror = function() {
      // Fallback: capture at displayed resolution
      downloadCanvas.width = img.clientWidth;
      downloadCanvas.height = img.clientHeight;
      
      const ctx = downloadCanvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      
      downloadCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `{{ doc.filename|replace('.pdf', '') }}_page_{{ page.page_index + 1 }}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };
    
    fullResImg.src = img.src;
  }
</script>
{% endif %}
{% endblock %}