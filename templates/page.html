{% extends "base.html" %}
{% set document_name = doc.filename if doc and doc.filename else None %}
{% block download_button %}
{% if user['role'] == 'student' %}
<button id="download-pdf-btn" class="button is-outlined is-small" onclick="downloadDocumentPDF(event)" style="color: #000000; border-color: #000000;">Download</button>
{% endif %}
{% endblock %}
{% block navigation_buttons %}
{% if page and page.document_id %}
<div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem;">
  <a class="button is-light is-small" href="{{ url_for('document', doc_id=page.document_id) }}">Pages</a>
  {% if prev_page_id %}
  <a class="button is-light is-small" href="{{ url_for('page', page_id=prev_page_id) }}">‚Üê Previous</a>
  {% endif %}
  {% if next_page_id %}
  <a class="button is-light is-small" href="{{ url_for('page', page_id=next_page_id) }}">Next ‚Üí</a>
  {% endif %}
</div>
{% endif %}
{% endblock %}
{% block content %}
<!-- Debug: User role is {{ user['role'] }} -->
<div class="box">
  <div class="level mb-4">
    <div class="level-right">
      <div class="level-item">
        <p class="has-text-grey">Page {{ page.page_index + 1 }}</p>
      </div>
    </div>
  </div>

  <div class="columns">

    <!-- LEFT: Canvas and tools -->
    <div class="column is-two-thirds">
      {% if user['role'] == 'student' %}
      <div class="toolbar mb-4">
        <div class="buttons">
          <div class="dropdown is-hoverable" id="color-picker-container">
            <div class="dropdown-trigger">
              <button class="button" id="color-picker-btn" aria-haspopup="true" aria-controls="color-menu" style="min-width: 80px; background-color: #000000; color: #FFFFFF;">
                Color
              </button>
            </div>
            <div class="dropdown-menu" id="color-menu" role="menu">
              <div class="dropdown-content" style="padding: 0.5rem;">
                <div class="color-picker-grid" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem; width: 200px;">
                  <button class="color-btn" data-color="#000000" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #000000;" title="Black"></button>
                  <button class="color-btn" data-color="#FFFFFF" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FFFFFF;" title="White"></button>
                  <button class="color-btn" data-color="#FF0000" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FF0000;" title="Red"></button>
                  <button class="color-btn" data-color="#00FF00" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #00FF00;" title="Green"></button>
                  <button class="color-btn" data-color="#0000FF" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #0000FF;" title="Blue"></button>
                  <button class="color-btn" data-color="#FFFF00" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FFFF00;" title="Yellow"></button>
                  <button class="color-btn" data-color="#FF00FF" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FF00FF;" title="Magenta"></button>
                  <button class="color-btn" data-color="#00FFFF" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #00FFFF;" title="Cyan"></button>
                  <button class="color-btn" data-color="#FFA500" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FFA500;" title="Orange"></button>
                  <button class="color-btn" data-color="#800080" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #800080;" title="Purple"></button>
                  <button class="color-btn" data-color="#FFC0CB" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #FFC0CB;" title="Pink"></button>
                  <button class="color-btn" data-color="#A52A2A" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #A52A2A;" title="Brown"></button>
                  <button class="color-btn" data-color="#808080" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #808080;" title="Gray"></button>
                  <button class="color-btn" data-color="#008000" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #008000;" title="Dark Green"></button>
                  <button class="color-btn" data-color="#000080" style="width: 100%; height: 35px; border: 2px solid #ccc; cursor: pointer; background-color: #000080;" title="Navy"></button>
                </div>
              </div>
            </div>
          </div>
          <input class="input" id="color-input" type="hidden" value="#000000">
          <button class="button is-dark is-outlined" id="tool-freehand">Freehand</button>
          <button class="button is-dark is-outlined" id="tool-rect">Rectangle</button>
          <button class="button is-dark is-outlined" id="tool-line">Line</button>
          <button class="button is-dark is-outlined" id="tool-text">Text</button>
          <button class="button is-dark is-outlined" id="tool-delete">Delete</button>
          <button class="button is-dark is-outlined" id="download-png-btn" href="#" onclick="downloadAnnotatedPNG(event); return false;" style="display: none;">
            <span>Download PNG</span>
          </button>
        </div>
      </div>
      {% endif %}

      <div style="position:relative; display:inline-block;">
        <img id="page-img"
             src="{{ page.image_url }}"
             class="page-image">
        {% if user['role'] == 'student' %}
        <canvas id="annot-canvas" style="position:absolute; left:0; top:0; pointer-events: auto;"></canvas>
        {% endif %}
      </div>
    </div>

    <!-- RIGHT: Emoji panel -->
    <div class="column is-one-third">
      {% if user['role'] == 'student' %}
      <h2 class="title is-5">How are you feeling on this page?</h2>
      <p class="mb-3 has-text-grey">Select one emotion. Only one can be active.</p>

      <div id="emoji-panel" class="is-flex is-flex-wrap-wrap" style="gap:.75rem;">
        <button class="button is-light emoji-btn" data-emoji="ü§©" title="Excited">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ü§©</span>
            <span style="font-size:.8rem;">Excited</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üôÇ" title="Okay/Happy">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üôÇ</span>
            <span style="font-size:.8rem;">Okay</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üòï" title="Confused">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üòï</span>
            <span style="font-size:.8rem;">Confused</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò§" title="Frustrated">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò§</span>
            <span style="font-size:.8rem;">Frustrated</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò¢" title="Overwhelmed">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò¢</span>
            <span style="font-size:.8rem;">Overwhelmed</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò¥" title="Bored/Tired">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò¥</span>
            <span style="font-size:.8rem;">Bored</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò°" title="Triggered">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò°</span>
            <span style="font-size:.8rem;">Triggered</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò≤" title="Surprised">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò≤</span>
            <span style="font-size:.8rem;">Surprised</span>
          </div>
        </button>
      </div>
      {% else %}
      <h2 class="title is-5">Student Emotions</h2>
      <p class="mb-3 has-text-grey">Emotion counts for this page:</p>

      <div class="box">
        <div class="content">
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ü§©</span>
              </div>
              <div class="level-item">
                <span><strong>Excited</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ü§©', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üôÇ</span>
              </div>
              <div class="level-item">
                <span><strong>Okay</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üôÇ', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üòï</span>
              </div>
              <div class="level-item">
                <span><strong>Confused</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üòï', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò§</span>
              </div>
              <div class="level-item">
                <span><strong>Frustrated</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò§', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò¢</span>
              </div>
              <div class="level-item">
                <span><strong>Overwhelmed</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò¢', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò¥</span>
              </div>
              <div class="level-item">
                <span><strong>Bored</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò¥', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò°</span>
              </div>
              <div class="level-item">
                <span><strong>Triggered</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò°', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò≤</span>
              </div>
              <div class="level-item">
                <span><strong>Surprised</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò≤', 0) }}</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      {% endif %}
    </div>

  </div>
</div>

{% if user['role'] == 'student' %}
<!-- Text Input Modal -->
<div class="modal" id="text-modal">
  <div class="modal-background"></div>
  <div class="modal-card">
    <header class="modal-card-head">
      <p class="modal-card-title">Enter Text</p>
      <button class="delete" aria-label="close" id="close-text-modal"></button>
    </header>
    <section class="modal-card-body">
      <textarea class="textarea" id="text-modal-input" placeholder="Enter your text here (up to 6 lines)" rows="6" style="min-height: 120px;"></textarea>
    </section>
    <footer class="modal-card-foot">
      <button class="button is-primary" id="submit-text-modal">Add Text</button>
      <button class="button" id="cancel-text-modal">Cancel</button>
    </footer>
  </div>
</div>
{% endif %}

<style>
  .emoji-btn.is-selected { box-shadow: 0 0 0 2px #485fc7 inset; }
  .modal-card {
    max-width: 500px;
  }
</style>

{% if user['role'] == 'student' %}
<script>
  const pageId = {{ page.id }};
  const existing = {{ annotations|tojson }};
  let currentEmoji = {{ (current_emoji or 'null')|tojson }};

  const img = document.getElementById('page-img');
  const canvas = document.getElementById('annot-canvas');
  const ctx = canvas.getContext('2d');

  const toolRectBtn = document.getElementById('tool-rect');
  const toolTextBtn = document.getElementById('tool-text');
  const toolLineBtn = document.getElementById('tool-line');
  const toolFreehandBtn = document.getElementById('tool-freehand');
  const deleteBtn   = document.getElementById('tool-delete');
  const colorInput = document.getElementById('color-input');
  const colorPickerBtn = document.getElementById('color-picker-btn');
  
  // Text modal elements
  const textModal = document.getElementById('text-modal');
  const textModalInput = document.getElementById('text-modal-input');
  const submitTextBtn = document.getElementById('submit-text-modal');
  const cancelTextBtn = document.getElementById('cancel-text-modal');
  const closeTextModalBtn = document.getElementById('close-text-modal');

  let tool = 'rect';
  let drawing = false;
  let startX = 0, startY = 0;
  let freehandPath = [];
  let pendingTextPosition = null; // Store x, y when text tool is clicked
  
  // Color picker setup
  const colorButtons = document.querySelectorAll('.color-btn');
  colorButtons.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const color = btn.getAttribute('data-color');
      colorInput.value = color;
      // Set solid background color
      colorPickerBtn.style.backgroundColor = color;
      // Set text color to white or black based on color brightness
      const rgb = hexToRgb(color);
      if (rgb) {
        const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        colorPickerBtn.style.color = brightness > 128 ? '#000000' : '#FFFFFF';
      } else {
        colorPickerBtn.style.color = '#FFFFFF';
      }
      // Close dropdown
      const dropdown = document.getElementById('color-picker-container');
      dropdown.classList.remove('is-active');
    });
  });
  
  // Helper function to convert hex to RGB
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }
  
  // Initialize color picker button
  if (colorPickerBtn) {
    // Set initial color based on colorInput value
    const initialColor = colorInput.value;
    colorPickerBtn.style.backgroundColor = initialColor;
    const rgb = hexToRgb(initialColor);
    if (rgb) {
      const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
      colorPickerBtn.style.color = brightness > 128 ? '#000000' : '#FFFFFF';
    } else {
      colorPickerBtn.style.color = '#FFFFFF';
    }
    
    colorPickerBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const dropdown = document.getElementById('color-picker-container');
      dropdown.classList.toggle('is-active');
    });
  }
  
  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    const dropdown = document.getElementById('color-picker-container');
    if (!dropdown.contains(e.target)) {
      dropdown.classList.remove('is-active');
    }
  });

  function setActiveTool(selectedTool) {
    tool = selectedTool;
    // Remove active class and add outlined class to all buttons
    [toolRectBtn, toolTextBtn, toolLineBtn, toolFreehandBtn, deleteBtn].forEach(btn => {
      if (btn) {
        btn.classList.remove('is-active');
        btn.classList.add('is-outlined');
      }
    });
    // Add active class and remove outlined class from selected button
    if (tool === 'rect') {
      toolRectBtn.classList.add('is-active');
      toolRectBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'text') {
      toolTextBtn.classList.add('is-active');
      toolTextBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'line') {
      toolLineBtn.classList.add('is-active');
      toolLineBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'freehand') {
      toolFreehandBtn.classList.add('is-active');
      toolFreehandBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'delete') {
      deleteBtn.classList.add('is-active');
      deleteBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'pointer';
    }
  }

  toolRectBtn.onclick = () => setActiveTool('rect');
  toolTextBtn.onclick = () => setActiveTool('text');
  toolLineBtn.onclick = () => setActiveTool('line');
  toolFreehandBtn.onclick = () => setActiveTool('freehand');
  deleteBtn.onclick = () => setActiveTool('delete');
  
  // Set initial active tool
  setActiveTool('freehand');

  function resizeCanvasToImage() {
    canvas.width = img.clientWidth;
    canvas.height = img.clientHeight;
    redraw();
  }
  img.addEventListener('load', resizeCanvasToImage);
  window.addEventListener('resize', resizeCanvasToImage);
  if (img.complete) resizeCanvasToImage();
  
  // Text modal functions
  function showTextModal(x, y) {
    if (!textModal || !textModalInput) return;
    pendingTextPosition = { x, y };
    textModalInput.value = '';
    textModal.classList.add('is-active');
    
    // Focus the input after a short delay to ensure modal is visible
    // Use requestAnimationFrame to ensure DOM updates are complete
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        textModalInput.focus();
      });
    });
  }
  
  function hideTextModal() {
    if (!textModal || !textModalInput) return;
    textModal.classList.remove('is-active');
    pendingTextPosition = null;
    textModalInput.value = '';
  }
  
  function submitTextFromModal() {
    const txt = textModalInput.value; // Don't trim - preserve line breaks
    if (!txt || !txt.trim()) {
      hideTextModal();
      return;
    }
    
    if (!pendingTextPosition) {
      hideTextModal();
      return;
    }
    
    const x = pendingTextPosition.x;
    const y = pendingTextPosition.y;
    
    // Calculate text dimensions - no wrapping, just measure actual lines
    ctx.font = '16px sans-serif';
    const lineHeight = 18;
    
    // Split by line breaks and measure each line
    const lines = txt.split('\n');
    let maxLineWidth = 0;
    
    for (let i = 0; i < lines.length; i++) {
      const metrics = ctx.measureText(lines[i]);
      maxLineWidth = Math.max(maxLineWidth, metrics.width);
    }
    
    // Store width and height for hit testing and display
    const textWidth = maxLineWidth;
    const textHeight = lines.length * lineHeight;
    
    saveAnnotation({ 
      kind: 'text', 
      x: x, 
      y: y, 
      w: textWidth,
      h: textHeight,
      text: txt, // Preserve line breaks
      color: colorInput.value 
    });
    
    hideTextModal();
  }
  
  // Modal event handlers - check if elements exist before adding listeners
  if (submitTextBtn) {
    submitTextBtn.addEventListener('click', submitTextFromModal);
  }
  if (cancelTextBtn) {
    cancelTextBtn.addEventListener('click', hideTextModal);
  }
  if (closeTextModalBtn) {
    closeTextModalBtn.addEventListener('click', hideTextModal);
  }
  
  // Close modal when clicking background
  if (textModal) {
    const modalBackground = textModal.querySelector('.modal-background');
    if (modalBackground) {
      modalBackground.addEventListener('click', hideTextModal);
    }
  }
  
  // Only Escape closes modal, Enter creates new line (no submit on Enter)
  if (textModalInput) {
    textModalInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideTextModal();
      }
      // Enter key is allowed to create new lines - no preventDefault or submit
    });
  }

  function drawAnnotation(a) {
    const color = a.color || '#000000';
    ctx.strokeStyle = color;
    // Increased transparency: 15 hex = ~8% opacity (was 40 = 25% opacity)
    ctx.fillStyle = a.kind === 'rect' ? `${color}15` : color;
    ctx.lineWidth = 2;

    if (a.kind === 'rect') {
      ctx.beginPath();
      ctx.rect(a.x, a.y, a.w, a.h);
      ctx.fill();
      ctx.stroke();
    } else if (a.kind === 'text') {
      ctx.font = '16px sans-serif';
      ctx.fillStyle = color;
      
      if (a.text) {
        // No word wrapping - only respect explicit line breaks
        const lineHeight = 18;
        let y = a.y;
        
        // Split by line breaks and render each line as-is
        const lines = a.text.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], a.x, y);
          y += lineHeight;
        }
      }
    } else if (a.kind === 'line') {
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(a.x + a.w, a.y + a.h);
      ctx.stroke();
    } else if (a.kind === 'freehand') {
      // Draw freehand path from stored points
      if (a.text) {
        try {
          const path = JSON.parse(a.text);
          if (Array.isArray(path) && path.length > 0) {
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
              ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
          }
        } catch (e) {
          console.error('Error parsing freehand path:', e);
        }
      }
    }
  }

  function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    existing.forEach(drawAnnotation);
  }

  function getCanvasCoordinates(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  canvas.addEventListener('mousedown', (e) => {
    // Prevent triggering canvas actions when clicking on color picker or modal
    const target = e.target;
    if (target.closest('#color-picker-container') || target.closest('#text-modal') || target.closest('.modal')) {
      return;
    }
    
    // Check if click is within toolbar area
    const toolbar = document.querySelector('.toolbar');
    if (toolbar && toolbar.contains(target)) {
      return;
    }
    
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      drawing = true;
      freehandPath = [{x, y}];
      // Start drawing immediately
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(x, y);
    } else if (tool === 'rect' || tool === 'line') {
      drawing = true;
      startX = x;
      startY = y;
    } else if (tool === 'text') {
      // Show modal for text input
      showTextModal(x, y);
    } else if (tool === 'delete') {
      const id = hitTest(x, y);
      if (id != null) deleteAnnotation(id);
    }
  });

  // Touch events for stylus/mobile support
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      drawing = true;
      freehandPath = [{x, y}];
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(x, y);
    } else if (tool === 'rect' || tool === 'line') {
      drawing = true;
      startX = x;
      startY = y;
    } else if (tool === 'text') {
      // Show modal for text input
      showTextModal(x, y);
    } else if (tool === 'delete') {
      const id = hitTest(x, y);
      if (id != null) deleteAnnotation(id);
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!drawing) return;
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      freehandPath.push({x, y});
      ctx.lineTo(x, y);
      ctx.stroke();
    } else if (tool === 'rect' || tool === 'line') {
      redraw();
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      if (tool === 'rect') ctx.strokeRect(startX, startY, x - startX, y - startY);
      if (tool === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    }
  });

  // Touch move for stylus/mobile support
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!drawing) return;
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      freehandPath.push({x, y});
      ctx.lineTo(x, y);
      ctx.stroke();
    } else if (tool === 'rect' || tool === 'line') {
      redraw();
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      if (tool === 'rect') ctx.strokeRect(startX, startY, x - startX, y - startY);
      if (tool === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    if (!drawing) return;
    
    if (tool === 'freehand') {
      if (freehandPath.length > 1) {
        // Calculate bounding box for freehand drawing
        const xs = freehandPath.map(p => p.x);
        const ys = freehandPath.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        
        const payload = {
          kind: 'freehand',
          x: minX,
          y: minY,
          w: maxX - minX,
          h: maxY - minY,
          text: JSON.stringify(freehandPath),
          color: colorInput.value
        };
        saveAnnotation(payload);
      }
      freehandPath = [];
    } else if (tool === 'rect' || tool === 'line') {
      const coords = getCanvasCoordinates(e);
      const endX = coords.x;
      const endY = coords.y;
      const w = endX - startX;
      const h = endY - startY;

      if (Math.abs(w) < 3 && Math.abs(h) < 3) {
        drawing = false;
        return;
      }
      const payload = { kind: tool, x: startX, y: startY, w, h, color: colorInput.value };
      saveAnnotation(payload);
    }
    
    drawing = false;
  });

  // Touch end for stylus/mobile support
  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (!drawing) return;
    
    if (tool === 'freehand') {
      if (freehandPath.length > 1) {
        const xs = freehandPath.map(p => p.x);
        const ys = freehandPath.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        
        const payload = {
          kind: 'freehand',
          x: minX,
          y: minY,
          w: maxX - minX,
          h: maxY - minY,
          text: JSON.stringify(freehandPath),
          color: colorInput.value
        };
        saveAnnotation(payload);
      }
      freehandPath = [];
    } else if (tool === 'rect' || tool === 'line') {
      const coords = getCanvasCoordinates(e);
      const endX = coords.x;
      const endY = coords.y;
      const w = endX - startX;
      const h = endY - startY;

      if (Math.abs(w) < 3 && Math.abs(h) < 3) {
        drawing = false;
        return;
      }
      const payload = { kind: tool, x: startX, y: startY, w, h, color: colorInput.value };
      saveAnnotation(payload);
    }
    
    drawing = false;
  });

  function saveAnnotation(payload) {
    fetch(`{{ url_for('annotate', page_id=page.id) }}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }).then(r => r.json()).then(resp => {
      if (resp.id) {
        // Add to existing array and redraw
        existing.push(resp);
        redraw();
      }
    }).catch(err => {
      console.error('Error saving annotation:', err);
      alert('Failed to save annotation');
    });
  }

  function deleteAnnotation(id) {
    fetch(`${window.BASE_PATH || ''}/annotations/${id}`, { method: 'DELETE' })
      .then(r => r.json())
      .then(resp => { if (resp.status === 'success') location.reload(); });
  }

  function hitTest(x, y) {
    for (let i = existing.length - 1; i >= 0; i--) {
      const a = existing[i];
      if (a.kind === 'rect') {
        if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) return a.id;
      } else if (a.kind === 'text') {
        // Use stored width/height if available, otherwise calculate
        const w = a.w || (10 + (a.text ? a.text.length * 8 : 20));
        const h = a.h || 20;
        if (x >= a.x - 5 && x <= a.x + w && y >= a.y - h && y <= a.y + 5) return a.id;
      } else if (a.kind === 'line') {
        const dist = Math.abs((a.h)*(x - a.x) - (a.w)*(y - a.y)) / Math.sqrt(a.h*a.h + a.w*a.w);
        if (dist < 5) return a.id;
      } else if (a.kind === 'freehand') {
        // Check if point is near any segment of the freehand path
        if (a.text) {
          try {
            const path = JSON.parse(a.text);
            if (Array.isArray(path) && path.length > 0) {
              // Check if point is within bounding box first (quick check)
              if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) {
                // Check distance to path segments
                for (let j = 0; j < path.length - 1; j++) {
                  const p1 = path[j];
                  const p2 = path[j + 1];
                  const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                  if (dist < 8) return a.id; // 8px threshold for freehand
                }
              }
            }
          } catch (e) {
            console.error('Error parsing freehand path in hitTest:', e);
          }
        }
      }
    }
    return null;
  }

  function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    if (lenSq !== 0) param = dot / lenSq;
    
    let xx, yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Emoji selection
  const panel = document.getElementById('emoji-panel');
  if (panel) {
    function setSelectedEmoji(emoji) {
      document.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.classList.toggle('is-selected', btn.dataset.emoji === emoji);
      });
    }
    if (currentEmoji) setSelectedEmoji(currentEmoji);
    
    panel.addEventListener('click', (e) => {
      const btn = e.target.closest('.emoji-btn');
      if (!btn) return;
      const emoji = btn.dataset.emoji;
      const newEmoji = emoji === currentEmoji ? null : emoji;
      fetch(`${window.BASE_PATH || ''}/page/${pageId}/reaction`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({emoji: newEmoji})
      }).then(r => {
        if (!r.ok) {
          throw new Error(`HTTP ${r.status}`);
        }
        return r.json().catch(() => {
          // If JSON parsing fails, but status was OK, assume success
          return {ok: true};
        });
      }).then(resp => {
        // Update UI regardless of response format if HTTP status was OK
        currentEmoji = newEmoji;
        setSelectedEmoji(newEmoji);
      }).catch(err => {
        console.error('Error saving reaction:', err);
        alert('Failed to save reaction. Please try again.');
      });
    });
  }

  // Function to draw annotation at full resolution
  function drawAnnotationAtFullRes(ctx, a, scaleX, scaleY) {
    const color = a.color || '#000000';
    ctx.strokeStyle = color;
    ctx.fillStyle = a.kind === 'rect' ? `${color}15` : color;
    ctx.lineWidth = 2 * scaleX; // Scale line width proportionally
    
    if (a.kind === 'rect') {
      const x = a.x * scaleX;
      const y = a.y * scaleY;
      const w = a.w * scaleX;
      const h = a.h * scaleY;
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.fill();
      ctx.stroke();
    } else if (a.kind === 'text') {
      // Scale font size proportionally
      const fontSize = Math.round(16 * scaleX);
      ctx.font = `${fontSize}px sans-serif`;
      ctx.fillStyle = color;
      
      if (a.text) {
        // No word wrapping - only respect explicit line breaks
        const lineHeight = Math.round(18 * scaleY);
        let y = a.y * scaleY;
        
        // Split by line breaks and render each line as-is
        const lines = a.text.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], a.x * scaleX, y);
          y += lineHeight;
        }
      }
    } else if (a.kind === 'line') {
      ctx.beginPath();
      ctx.moveTo(a.x * scaleX, a.y * scaleY);
      ctx.lineTo((a.x + a.w) * scaleX, (a.y + a.h) * scaleY);
      ctx.stroke();
    } else if (a.kind === 'freehand') {
      if (a.text) {
        try {
          const path = JSON.parse(a.text);
          if (Array.isArray(path) && path.length > 0) {
            ctx.beginPath();
            ctx.moveTo(path[0].x * scaleX, path[0].y * scaleY);
            for (let i = 1; i < path.length; i++) {
              ctx.lineTo(path[i].x * scaleX, path[i].y * scaleY);
            }
            ctx.stroke();
          }
        } catch (e) {
          console.error('Error parsing freehand path:', e);
        }
      }
    }
  }

  // Download PNG with annotations - render at full resolution
  function downloadAnnotatedPNG(event) {
    event.preventDefault();
    
    // Get the displayed image element
    const img = document.getElementById('page-img');
    if (!img) {
      alert('Image not found');
      return;
    }
    
    // Create a new canvas to combine image and annotations
    const downloadCanvas = document.createElement('canvas');
    
    // Load the full-resolution image
    const fullResImg = new Image();
    fullResImg.crossOrigin = 'anonymous'; // Handle CORS if needed
    
    fullResImg.onload = function() {
      // Set canvas to full image resolution
      downloadCanvas.width = fullResImg.naturalWidth;
      downloadCanvas.height = fullResImg.naturalHeight;
      
      const ctx = downloadCanvas.getContext('2d');
      
      // Draw the full-resolution image
      ctx.drawImage(fullResImg, 0, 0);
      
      // Calculate scale factor from displayed size to full resolution
      // CRITICAL: Use canvas dimensions, not img.clientWidth, because annotations are stored
      // relative to canvas.width/height (which may be rounded integers)
      const displayedWidth = canvas.width;
      const displayedHeight = canvas.height;
      const scaleX = fullResImg.naturalWidth / displayedWidth;
      const scaleY = fullResImg.naturalHeight / displayedHeight;
      
      // Redraw all annotations at full resolution
      existing.forEach(function(annotation) {
        drawAnnotationAtFullRes(ctx, annotation, scaleX, scaleY);
      });
      
      // Convert to blob and download
      downloadCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `{{ doc.filename|replace('.pdf', '') }}_page_{{ page.page_index + 1 }}_annotated.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };
    
    fullResImg.onerror = function() {
      // Fallback: capture at displayed resolution if full-res fails
      downloadCanvas.width = img.clientWidth;
      downloadCanvas.height = img.clientHeight;
      
      const ctx = downloadCanvas.getContext('2d');
      
      // Draw the displayed image
      ctx.drawImage(img, 0, 0);
      
      // Draw the annotation canvas
      ctx.drawImage(canvas, 0, 0);
      
      // Convert to blob and download
      downloadCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `{{ doc.filename|replace('.pdf', '') }}_page_{{ page.page_index + 1 }}_annotated.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };
    
    // Load the full-resolution image
    fullResImg.src = img.src;
  }

  // Function to generate annotated PNG for a page - uses EXACT same logic as downloadAnnotatedPNG
  // Returns: { dataUrl: string, width: number, height: number }
  function generateAnnotatedPNGForPage(pageImageUrl, annotations) {
    return new Promise((resolve, reject) => {
      // Check if this is the current page - if so, use exact same logic as downloadAnnotatedPNG
      const currentImg = document.getElementById('page-img');
      let displayedWidth, displayedHeight;
      
      // Normalize URLs for comparison
      const normalizeUrl = (url) => {
        try {
          const u = new URL(url, window.location.href);
          return u.pathname + u.search;
        } catch {
          return url;
        }
      };
      
      const currentImgSrc = currentImg ? normalizeUrl(currentImg.src) : null;
      const targetImgSrc = normalizeUrl(pageImageUrl);
      
      if (currentImg && currentImgSrc === targetImgSrc && currentImg.clientWidth > 0) {
        // Same page - use canvas dimensions (annotations are stored relative to canvas, not img)
        // This is EXACTLY what downloadAnnotatedPNG does
        const currentCanvas = document.getElementById('annot-canvas');
        if (currentCanvas && currentCanvas.width > 0 && currentCanvas.height > 0) {
          displayedWidth = currentCanvas.width;
          displayedHeight = currentCanvas.height;
        } else {
          // Fallback to image dimensions if canvas not available
          displayedWidth = currentImg.clientWidth;
          displayedHeight = currentImg.clientHeight;
        }
        generatePNG();
      } else {
        // Different page - need to measure it accurately to match how canvas would be sized
        // Create a temporary image element in the same container structure
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'absolute';
        tempContainer.style.top = '-9999px';
        tempContainer.style.left = '-9999px';
        tempContainer.style.width = '66.666%'; // Match is-two-thirds column
        tempContainer.style.maxWidth = '66.666%';
        tempContainer.style.visibility = 'hidden';
        
        const tempImg = document.createElement('img');
        tempImg.style.width = '100%';
        tempImg.style.height = 'auto';
        tempImg.style.display = 'block';
        tempImg.crossOrigin = 'anonymous';
        tempContainer.appendChild(tempImg);
        document.body.appendChild(tempContainer);
        
        tempImg.onload = function() {
          // Force reflow
          void tempContainer.offsetWidth;
          
          // Use clientWidth/clientHeight, but round to integers to match canvas behavior
          // Canvas dimensions are always integers, so annotations are stored relative to rounded dimensions
          displayedWidth = Math.round(tempImg.clientWidth);
          displayedHeight = Math.round(tempImg.clientHeight);
          
          if (!displayedWidth || !displayedHeight || displayedWidth === 0 || displayedHeight === 0) {
            document.body.removeChild(tempContainer);
            reject(new Error('Failed to get valid dimensions for image'));
            return;
          }
          
          document.body.removeChild(tempContainer);
          generatePNG();
        };
        
        tempImg.onerror = function() {
          document.body.removeChild(tempContainer);
          reject(new Error('Failed to load image: ' + pageImageUrl));
        };
        
        tempImg.src = pageImageUrl;
      }
      
      function generatePNG() {
        // Load the full-resolution image - EXACT same as downloadAnnotatedPNG
        const fullResImg = new Image();
        fullResImg.crossOrigin = 'anonymous';
        
        fullResImg.onload = function() {
          // Create canvas at full image resolution - EXACT same as downloadAnnotatedPNG
          const downloadCanvas = document.createElement('canvas');
          downloadCanvas.width = fullResImg.naturalWidth;
          downloadCanvas.height = fullResImg.naturalHeight;
          const ctx = downloadCanvas.getContext('2d');
          
          // Draw the full-resolution image
          ctx.drawImage(fullResImg, 0, 0);
          
          // Calculate scale factor - EXACT same as downloadAnnotatedPNG
          const scaleX = fullResImg.naturalWidth / displayedWidth;
          const scaleY = fullResImg.naturalHeight / displayedHeight;
          
          // Redraw all annotations at full resolution - EXACT same function
          if (annotations && annotations.length > 0) {
            annotations.forEach(function(annotation) {
              drawAnnotationAtFullRes(ctx, annotation, scaleX, scaleY);
            });
          }
          
          // Convert to data URL - EXACT same as downloadAnnotatedPNG
          // Return both the data URL and the exact canvas dimensions
          try {
            const dataUrl = downloadCanvas.toDataURL('image/png');
            if (dataUrl && dataUrl.startsWith('data:')) {
              resolve({
                dataUrl: dataUrl,
                width: downloadCanvas.width,
                height: downloadCanvas.height
              });
            } else {
              reject(new Error('Failed to generate PNG data URL'));
            }
          } catch (err) {
            reject(new Error('Failed to generate PNG: ' + err.message));
          }
        };
        
        fullResImg.onerror = function() {
          reject(new Error('Failed to load full-resolution image: ' + pageImageUrl));
        };
        
        fullResImg.src = pageImageUrl;
      }
    });
  }

  // Function to download entire document as PDF
  async function downloadDocumentPDF(event) {
    event.preventDefault();
    
    const btn = event.target;
    const originalText = btn.textContent;
    btn.disabled = true;
    btn.textContent = 'Generating PDF...';
    
    try {
      // Fetch all pages for this document
      const docResponse = await fetch(`${window.BASE_PATH || ''}/doc/{{ page.document_id }}`);
      const docText = await docResponse.text();
      
      // Parse page IDs from the HTML
      const pageIdRegex = /page\/(\d+)/g;
      const pageIds = [];
      let match;
      while ((match = pageIdRegex.exec(docText)) !== null) {
        pageIds.push(parseInt(match[1]));
      }
      
      // Remove duplicates
      const uniquePageIds = [...new Set(pageIds)];
      
      if (uniquePageIds.length === 0) {
        throw new Error('No pages found for document');
      }
      
      // Fetch all pages to get their indices and data
      const pagesWithData = await Promise.all(
        uniquePageIds.map(async (pageId) => {
          try {
            const response = await fetch(`${window.BASE_PATH || ''}/page/${pageId}.json`);
            const data = await response.json();
            return {
              id: pageId,
              page_index: data.page_index,
              image_url: data.image_url,
              annotations: data.annotations || []
            };
          } catch (e) {
            console.error(`Error fetching page ${pageId}:`, e);
            return null;
          }
        })
      );
      
      // Filter out nulls and sort by page_index
      const sortedPages = pagesWithData
        .filter(p => p !== null)
        .sort((a, b) => a.page_index - b.page_index);
      
      if (sortedPages.length === 0) {
        throw new Error('No pages found for document');
      }
      
      const { jsPDF } = window.jspdf;
      let pdf = null;
      const docFilename = '{{ doc.filename|replace(".pdf", "") }}';
      
      // Process each page
      for (let i = 0; i < sortedPages.length; i++) {
        const page = sortedPages[i];
        btn.textContent = `Processing page ${i + 1} of ${sortedPages.length}...`;
        
        // Generate annotated PNG using EXACT same logic as single-page download
        // Returns both data URL and exact dimensions
        const pagePNG = await generateAnnotatedPNGForPage(page.image_url, page.annotations);
        
        // Use the exact canvas dimensions from PNG generation (1:1 ratio - no scaling, no margins)
        // This ensures perfect alignment - these are the exact dimensions used when creating the PNG
        const imgWidthPt = pagePNG.width;
        const imgHeightPt = pagePNG.height;
        
        // Set PDF page size to match PNG exactly (no margins)
        if (i === 0) {
          pdf = new jsPDF({
            orientation: imgWidthPt > imgHeightPt ? 'landscape' : 'portrait',
            unit: 'pt',
            format: [imgWidthPt, imgHeightPt],
            compress: true
          });
          // Remove any default margins
          pdf.setPage(1);
        } else {
          pdf.addPage([imgWidthPt, imgHeightPt], imgWidthPt > imgHeightPt ? 'landscape' : 'portrait');
        }
        
        // Get current page and ensure no margins
        const currentPage = pdf.internal.getCurrentPageInfo().pageNumber;
        pdf.setPage(currentPage);
        
        // Add image to PDF at exact dimensions, starting at (0, 0) with no margins
        // Use the exact pixel dimensions - 1 pixel = 1 point for perfect alignment
        pdf.addImage(pagePNG.dataUrl, 'PNG', 0, 0, imgWidthPt, imgHeightPt, undefined, 'FAST');
      }
      
      // Save the PDF
      pdf.save(`${docFilename}_annotated.pdf`);
      
      btn.disabled = false;
      btn.textContent = originalText;
    } catch (error) {
      console.error('Error generating PDF:', error);
      alert('Error generating PDF: ' + error.message);
      btn.disabled = false;
      btn.textContent = originalText;
    }
  }

</script>
{% else %}
<script>
  // Download PNG function for teachers (no annotations, just the page image)
  function downloadAnnotatedPNG(event) {
    event.preventDefault();
    
    const img = document.getElementById('page-img');
    if (!img) {
      alert('Image not found');
      return;
    }
    
    // Create a canvas to capture the image
    const downloadCanvas = document.createElement('canvas');
    
    // Load the full-resolution image
    const fullResImg = new Image();
    fullResImg.crossOrigin = 'anonymous';
    
    fullResImg.onload = function() {
      // Set canvas to full image resolution
      downloadCanvas.width = fullResImg.naturalWidth;
      downloadCanvas.height = fullResImg.naturalHeight;
      
      const ctx = downloadCanvas.getContext('2d');
      ctx.drawImage(fullResImg, 0, 0);
      
      // Convert to blob and download
      downloadCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `{{ doc.filename|replace('.pdf', '') }}_page_{{ page.page_index + 1 }}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };
    
    fullResImg.onerror = function() {
      // Fallback: capture at displayed resolution
      downloadCanvas.width = img.clientWidth;
      downloadCanvas.height = img.clientHeight;
      
      const ctx = downloadCanvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      
      downloadCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `{{ doc.filename|replace('.pdf', '') }}_page_{{ page.page_index + 1 }}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    };
    
    fullResImg.src = img.src;
  }
</script>
{% endif %}
{% endblock %}